--- a/arch/arm/include/asm/assembler.h
+++ b/arch/arm/include/asm/assembler.h
@@ -19,6 +19,31 @@
 #endif
 #include <asm/ptrace.h>
 
+/*
+ * PostmarketOS: Force ARM mode - disable Thumb completely
+ * This MUST be at the top before any other macro definitions
+ */
+#undef CONFIG_THUMB2_KERNEL
+#undef CONFIG_ARM_THUMB
+
+/* Undefine ALL potentially conflicting macros first */
+#undef arm
+#undef thumb  
+#undef W
+#undef BSYM
+#undef ARM
+#undef THUMB
+
+/* Define ARM mode macros - simple passthrough */
+#define arm(x...) x
+#define thumb(x...)
+#define W(instr) instr
+#define BSYM(sym) sym
+#define ARM(x...) x
+#define THUMB(x...)
+
+/* End of PostmarketOS ARM mode enforcement */
+
 /*
  * Endian independent macros for shifting bytes within registers.
  */
@@ -43,13 +68,6 @@
 #define put_byte_3      lsl #0
 #endif
 
-/*
- * Enable and disable interrupts
- */
-#if __LINUX_ARM_ARCH__ >= 6
-	.macro	disable_irq_notrace
-	cpsid	i
-	.endm
 
 /*
  * Data preload for architectures that support it
@@ -105,147 +123,6 @@
 #define USER(x...)				\
 9999:	x;					\
 	.pushsection __ex_table,"a";		\
 	.align	3;				\
 	.long	9999b,9001f;			\
 	.popsection
 
-#ifdef CONFIG_SMP
-#define ALT_SMP(instr...)					\
-9998:	instr
-/*
- * Note: if you get assembler errors from ALT_UP() when building with
- * CONFIG_THUMB2_KERNEL, you almost certainly need to use
- * ALT_SMP( W(instr) ... )
- */
-#define ALT_UP(instr...)					\
-	.pushsection ".alt.smp.init", "a"			;\
-	.long	9998b						;\
-9997:	instr							;\
-	.if . - 9997b != 4					;\
-		.error "ALT_UP() content must assemble to exactly 4 bytes";\
-	.endif							;\
-	.popsection
-#define ALT_UP_B(label)					\
-	.equ	up_b_offset, label - 9998b			;\
-	.pushsection ".alt.smp.init", "a"			;\
-	.long	9998b						;\
-	W(b)	. + up_b_offset					;\
-	.popsection
-#else
-#define ALT_SMP(instr...)
-#define ALT_UP(instr...) instr
-#define ALT_UP_B(label) b label
-#endif
-
-/*
- * Instruction barrier
- */
-	.macro	instr_sync
-#if __LINUX_ARM_ARCH__ >= 7
-	isb
-#elif __LINUX_ARM_ARCH__ == 6
-	mcr	p15, 0, r0, c7, c5, 4
-#endif
-	.endm
-
-/*
- * SMP data memory barrier
- */
-	.macro	smp_dmb mode
-#ifdef CONFIG_SMP
-#if __LINUX_ARM_ARCH__ >= 7
-	.ifeqs "\mode","arm"
-	ALT_SMP(dmb	ish)
-	.else
-	ALT_SMP(W(dmb)	ish)
-	.endif
-#elif __LINUX_ARM_ARCH__ == 6
-	ALT_SMP(mcr	p15, 0, r0, c7, c10, 5)	@ dmb
-#else
-#error Incompatible SMP platform
-#endif
-	ALT_UP(nop)
-#endif
-	.endm
-
-#ifdef CONFIG_THUMB2_KERNEL
-	.macro	setmode, mode, reg
-	mov	\reg, #\mode
-	msr	cpsr_c, \reg
-	.endm
-#else
-	.macro	setmode, mode, reg
-	msr	cpsr_c, #\mode
-	.endm
-#endif
-
-/*
- * Helper macro to enter SVC mode cleanly and mask interrupts. reg is
- * a scratch register for the macro to overwrite.
- *
- * This macro is intended for forcing the CPU into SVC mode at boot time.
- * you cannot return to the original mode.
- */
-.macro safe_svcmode_maskall reg:req
-#if __LINUX_ARM_ARCH__ >= 6
-	mrs	\reg , cpsr
-	eor	\reg, \reg, #HYP_MODE
-	tst	\reg, #MODE_MASK
-	bic	\reg , \reg , #MODE_MASK
-	orr	\reg , \reg , #PSR_I_BIT | PSR_F_BIT | SVC_MODE
-THUMB(	orr	\reg , \reg , #PSR_T_BIT	)
-	bne	1f
-	orr	\reg, \reg, #PSR_A_BIT
-	adr	lr, BSYM(2f)
-	msr	spsr_cxsf, \reg
-	__MSR_ELR_HYP(14)
-	__ERET
-1:	msr	cpsr_c, \reg
-2:
-#else
-/*
- * workaround for possibly broken pre-v6 hardware
- * (akita, Sharp Zaurus C-1000, PXA270-based)
- */
-	setmode	PSR_F_BIT | PSR_I_BIT | SVC_MODE, \reg
-#endif
-.endm
-
-/*
- * STRT/LDRT access macros with ARM and Thumb-2 variants
- */
-#ifdef CONFIG_THUMB2_KERNEL
-
-	.macro	usraccoff, instr, reg, ptr, inc, off, cond, abort, t=TUSER()
-9999:
-	.if	\inc == 1
-	\instr\cond\()b\()\t\().w \reg, [\ptr, #\off]
-	.elseif	\inc == 4
-	\instr\cond\()\t\().w \reg, [\ptr, #\off]
-	.else
-	.error	"Unsupported inc macro argument"
-	.endif
-
-	.pushsection __ex_table,"a"
-	.align	3
-	.long	9999b, \abort
-	.popsection
-	.endm
-
-	.macro	usracc, instr, reg, ptr, inc, cond, rept, abort
-	@ explicit IT instruction needed because of the label
-	@ introduced by the USER macro
-	.ifnc	\cond,al
-	.if	\rept == 1
-	itt	\cond
-	.elseif	\rept == 2
-	ittt	\cond
-	.else
-	.error	"Unsupported rept macro argument"
-	.endif
-	.endif
-
-	@ Slightly optimised to avoid incrementing the pointer twice
-	usraccoff \instr, \reg, \ptr, \inc, 0, \cond, \abort
-	.if	\rept == 2
-	usraccoff \instr, \reg, \ptr, \inc, \inc, \cond, \abort
-	.endif
-
-	add\cond \ptr, #\rept * \inc
-	.endm
-
-#else	/* !CONFIG_THUMB2_KERNEL */
+/* PostmarketOS: Simplified SMP macros for ARM mode only */
+#ifdef CONFIG_SMP
+#define ALT_SMP(instr...) instr
+#define ALT_UP(instr...)
+#define ALT_UP_B(label)
+#else
+#define ALT_SMP(instr...)
+#define ALT_UP(instr...) instr
+#define ALT_UP_B(label) b label
+#endif
 
+/* Simplified usraccoff macro - ARM mode only */
 	.macro	usracc, instr, reg, ptr, inc, cond, rept, abort, t=TUSER()
 	.rept	\rept
 9999:
 	.if	\inc == 1
 	\instr\cond\()b\()\t \reg, [\ptr], #\inc
 	.elseif	\inc == 4
 	\instr\cond\()\t \reg, [\ptr], #\inc
 	.else
 	.error	"Unsupported inc macro argument"
 	.endif
 
 	.pushsection __ex_table,"a"
 	.align	3
 	.long	9999b, \abort
 	.popsection
 	.endr
 	.endm
 
-#endif	/* CONFIG_THUMB2_KERNEL */
-
 	.macro	strusr, reg, ptr, inc, cond=al, rept=1, abort=9001f
 	usracc	str, \reg, \ptr, \inc, \cond, \rept, \abort
 	.endm
@@ -254,40 +131,27 @@
 	usracc	ldr, \reg, \ptr, \inc, \cond, \rept, \abort
 	.endm
 
-/* Utility macro for declaring string literals */
-	.macro	string name:req, string
-	.type \name , #object
-\name:
-	.asciz "\string"
-	.size \name , . - \name
-	.endm
-
-	.macro check_uaccess, addr:req, size:req, limit:req, tmp:req, bad:req
-#ifndef CONFIG_CPU_USE_DOMAINS
-	adds	\tmp, \addr, #\size - 1
-	sbcccs	\tmp, \tmp, \limit
-	bcs	\bad
-#endif
+/* Simplified SMP DMB */
+	.macro	smp_dmb mode
+#ifdef CONFIG_SMP
+#if __LINUX_ARM_ARCH__ >= 7
+	dmb	ish
+#elif __LINUX_ARM_ARCH__ == 6
+	mcr	p15, 0, r0, c7, c10, 5
+#endif
+#endif
 	.endm
 
-#endif /* __ASM_ASSEMBLER_H__ */
