diff --git a/include/linux/byteorder.h b/include/linux/byteorder.h
new file mode 100644
index 0000000..1234567
--- /dev/null
+++ b/include/linux/byteorder.h
@@ -0,0 +1,15 @@
+#ifndef _LINUX_BYTEORDER_H
+#define _LINUX_BYTEORDER_H
+
+/* PostmarketOS: Minimal byteorder.h */
+
+#include <linux/types.h>
+
+/* Include the architecture specific byte order definition */
+#ifdef __ARMEB__
+#include <linux/byteorder/big_endian.h>
+#else
+#include <linux/byteorder/little_endian.h>
+#endif
+
+#endif /* _LINUX_BYTEORDER_H */
diff --git a/include/linux/swab.h b/include/linux/swab.h
new file mode 100644
index 0000000..1234567
--- /dev/null
+++ b/include/linux/swab.h
@@ -0,0 +1,98 @@
+#ifndef _LINUX_SWAB_H
+#define _LINUX_SWAB_H
+
+#include <linux/types.h>
+#include <linux/compiler.h>
+#include <asm/swab.h>
+
+/* PostmarketOS: Minimal swab.h for byte swapping */
+
+#define ___swab16(x) \
+({ \
+    __u16 __x = (x); \
+    ((__u16)( \
+        (((__u16)(__x) & (__u16)0x00ffU) << 8) | \
+        (((__u16)(__x) & (__u16)0xff00U) >> 8) )); \
+})
+
+#define ___swab32(x) \
+({ \
+    __u32 __x = (x); \
+    ((__u32)( \
+        (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | \
+        (((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) | \
+        (((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) | \
+        (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); \
+})
+
+#define ___swab64(x) \
+({ \
+    __u64 __x = (x); \
+    ((__u64)( \
+        (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
+        (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
+        (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+        (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+        (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+        (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+        (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+        (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); \
+})
+
+#define ___constant_swab16(x) ((__u16)( \
+	(((__u16)(x) & (__u16)0x00ffU) << 8) | \
+	(((__u16)(x) & (__u16)0xff00U) >> 8)))
+
+#define ___constant_swab32(x) ((__u32)( \
+	(((__u32)(x) & (__u32)0x000000ffUL) << 24) | \
+	(((__u32)(x) & (__u32)0x0000ff00UL) <<  8) | \
+	(((__u32)(x) & (__u32)0x00ff0000UL) >>  8) | \
+	(((__u32)(x) & (__u32)0xff000000UL) >> 24)))
+
+#define ___constant_swab64(x) ((__u64)( \
+	(((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | \
+	(((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) | \
+	(((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+	(((__u64)(x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+	(((__u64)(x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+	(((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+	(((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+	(((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56)))
+
+static inline __u16 __swab16p(const __u16 *p) { return ___swab16(*p); }
+static inline __u32 __swab32p(const __u32 *p) { return ___swab32(*p); }
+static inline __u64 __swab64p(const __u64 *p) { return ___swab64(*p); }
+static inline void __swab16s(__u16 *p) { *p = __swab16p(p); }
+static inline void __swab32s(__u32 *p) { *p = __swab32p(p); }
+static inline void __swab64s(__u64 *p) { *p = __swab64p(p); }
+
+#define __swab16(x) ___swab16(x)
+#define __swab32(x) ___swab32(x)
+#define __swab64(x) ___swab64(x)
+
+#endif /* _LINUX_SWAB_H */
diff --git a/include/linux/byteorder/little_endian.h b/include/linux/byteorder/little_endian.h
new file mode 100644
index 0000000..1234567
--- /dev/null
+++ b/include/linux/byteorder/little_endian.h
@@ -0,0 +1,69 @@
+#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H
+
+#include <linux/types.h>
+#include <linux/swab.h>
+
+#define __LITTLE_ENDIAN 1234
+#define __BIG_ENDIAN 4321
+#define __PDP_ENDIAN 3412
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+/* Little endian definitions */
+#define __constant_htonl(x) ((__force __be32)___constant_swab32((x)))
+#define __constant_ntohl(x) ___constant_swab32((__force __be32)(x))
+#define __constant_htons(x) ((__force __be16)___constant_swab16((x)))
+#define __constant_ntohs(x) ___constant_swab16((__force __be16)(x))
+#define __constant_cpu_to_le64(x) ((__force __le64)(__u64)(x))
+#define __constant_le64_to_cpu(x) ((__force __u64)(__le64)(x))
+#define __constant_cpu_to_le32(x) ((__force __le32)(__u32)(x))
+#define __constant_le32_to_cpu(x) ((__force __u32)(__le32)(x))
+#define __constant_cpu_to_le16(x) ((__force __le16)(__u16)(x))
+#define __constant_le16_to_cpu(x) ((__force __u16)(__le16)(x))
+#define __constant_cpu_to_be64(x) ((__force __be64)___constant_swab64((x)))
+#define __constant_be64_to_cpu(x) ___constant_swab64((__force __be64)(x))
+#define __constant_cpu_to_be32(x) ((__force __be32)___constant_swab32((x)))
+#define __constant_be32_to_cpu(x) ___constant_swab32((__force __be32)(x))
+#define __constant_cpu_to_be16(x) ((__force __be16)___constant_swab16((x)))
+#define __constant_be16_to_cpu(x) ___constant_swab16((__force __be16)(x))
+
+#define __cpu_to_le64(x) ((__force __le64)(__u64)(x))
+#define __le64_to_cpu(x) ((__force __u64)(__le64)(x))
+#define __cpu_to_le32(x) ((__force __le32)(__u32)(x))
+#define __le32_to_cpu(x) ((__force __u32)(__le32)(x))
+#define __cpu_to_le16(x) ((__force __le16)(__u16)(x))
+#define __le16_to_cpu(x) ((__force __u16)(__le16)(x))
+#define __cpu_to_be64(x) ((__force __be64)__swab64((x)))
+#define __be64_to_cpu(x) __swab64((__force __u64)(__be64)(x))
+#define __cpu_to_be32(x) ((__force __be32)__swab32((x)))
+#define __be32_to_cpu(x) __swab32((__force __u32)(__be32)(x))
+#define __cpu_to_be16(x) ((__force __be16)__swab16((x)))
+#define __be16_to_cpu(x) __swab16((__force __u16)(__be16)(x))
+
+static inline __le64 __cpu_to_le64p(const __u64 *p) { return (__force __le64)*p; }
+static inline __u64 __le64_to_cpup(const __le64 *p) { return (__force __u64)*p; }
+static inline __le32 __cpu_to_le32p(const __u32 *p) { return (__force __le32)*p; }
+static inline __u32 __le32_to_cpup(const __le32 *p) { return (__force __u32)*p; }
+static inline __le16 __cpu_to_le16p(const __u16 *p) { return (__force __le16)*p; }
+static inline __u16 __le16_to_cpup(const __le16 *p) { return (__force __u16)*p; }
+static inline __be64 __cpu_to_be64p(const __u64 *p) { return (__force __be64)__swab64p(p); }
+static inline __u64 __be64_to_cpup(const __be64 *p) { return __swab64p((__u64 *)p); }
+static inline __be32 __cpu_to_be32p(const __u32 *p) { return (__force __be32)__swab32p(p); }
+static inline __u32 __be32_to_cpup(const __be32 *p) { return __swab32p((__u32 *)p); }
+static inline __be16 __cpu_to_be16p(const __u16 *p) { return (__force __be16)__swab16p(p); }
+static inline __u16 __be16_to_cpup(const __be16 *p) { return __swab16p((__u16 *)p); }
+
+#define __cpu_to_le64s(x) do { (void)(x); } while (0)
+#define __le64_to_cpus(x) do { (void)(x); } while (0)
+#define __cpu_to_le32s(x) do { (void)(x); } while (0)
+#define __le32_to_cpus(x) do { (void)(x); } while (0)
+#define __cpu_to_le16s(x) do { (void)(x); } while (0)
+#define __le16_to_cpus(x) do { (void)(x); } while (0)
+#define __cpu_to_be64s(x) __swab64s((x))
+#define __be64_to_cpus(x) __swab64s((x))
+#define __cpu_to_be32s(x) __swab32s((x))
+#define __be32_to_cpus(x) __swab32s((x))
+#define __cpu_to_be16s(x) __swab16s((x))
+#define __be16_to_cpus(x) __swab16s((x))
+
+#include <linux/byteorder/generic.h>
+
+#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
diff --git a/include/linux/byteorder/generic.h b/include/linux/byteorder/generic.h
new file mode 100644
index 0000000..1234567
--- /dev/null
+++ b/include/linux/byteorder/generic.h
@@ -0,0 +1,40 @@
+#ifndef _LINUX_BYTEORDER_GENERIC_H
+#define _LINUX_BYTEORDER_GENERIC_H
+
+/* PostmarketOS: Generic byte order conversions */
+
+#define cpu_to_le64 __cpu_to_le64
+#define le64_to_cpu __le64_to_cpu
+#define cpu_to_le32 __cpu_to_le32
+#define le32_to_cpu __le32_to_cpu
+#define cpu_to_le16 __cpu_to_le16
+#define le16_to_cpu __le16_to_cpu
+#define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
+#define cpu_to_be32 __cpu_to_be32
+#define be32_to_cpu __be32_to_cpu
+#define cpu_to_be16 __cpu_to_be16
+#define be16_to_cpu __be16_to_cpu
+
+#define cpu_to_le64p __cpu_to_le64p
+#define le64_to_cpup __le64_to_cpup
+#define cpu_to_le32p __cpu_to_le32p
+#define le32_to_cpup __le32_to_cpup
+#define cpu_to_le16p __cpu_to_le16p
+#define le16_to_cpup __le16_to_cpup
+#define cpu_to_be64p __cpu_to_be64p
+#define be64_to_cpup __be64_to_cpup
+#define cpu_to_be32p __cpu_to_be32p
+#define be32_to_cpup __be32_to_cpup
+#define cpu_to_be16p __cpu_to_be16p
+#define be16_to_cpup __be16_to_cpup
+
+#define cpu_to_le64s __cpu_to_le64s
+#define le64_to_cpus __le64_to_cpus
+#define cpu_to_le32s __cpu_to_le32s
+#define le32_to_cpus __le32_to_cpus
+#define cpu_to_le16s __cpu_to_le16s
+#define le16_to_cpus __le16_to_cpus
+#define cpu_to_be64s __cpu_to_be64s
+#define be64_to_cpus __be64_to_cpus
+#define cpu_to_be32s __cpu_to_be32s
+#define be32_to_cpus __be32_to_cpus
+#define cpu_to_be16s __cpu_to_be16s
+#define be16_to_cpus __be16_to_cpus
+
+#define htonl(x) __cpu_to_be32(x)
+#define ntohl(x) __be32_to_cpu(x)
+#define htons(x) __cpu_to_be16(x)
+#define ntohs(x) __be16_to_cpu(x)
+
+#endif /* _LINUX_BYTEORDER_GENERIC_H */
