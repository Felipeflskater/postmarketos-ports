# Maintainer: Felipe Prestes Aranalde <felipe.aranalde@gmail.com>
pkgname=linux-samsung-matisse3g
pkgver=3.4.113
pkgrel=60
pkgdesc="Kernel Linux para Samsung Galaxy Tab 4 10.1 (SM-T531) - Otimizado para PostmarketOS"
arch="armv7"
_flavor="samsung-matisse3g"
url="https://github.com/felipeflskater/android_kernel_samsung_msm8226"
license="GPL-2.0-only"
options="!strip !check !tracedeps pmb:cross-native"
makedepends="
	bash bc bison devicepkg-dev dtbtool elfutils-dev findutils flex
	gmp-dev installkernel linux-headers mpc1-dev mpfr-dev
	perl python3 sed xz gcc-arm-none-eabi
"

_commit="pmos-matisse3g-fixes"

source="
	$pkgname-$_commit.tar.gz::https://github.com/Felipeflskater/android_kernel_samsung_msm8226/archive/refs/heads/$_commit.tar.gz
	config-samsung-matisse3g.armv7
	01-fix-timex-header.patch
	03-fix-defconfig.patch
	04-fix-jffs2-format-warnings.patch
	05-fix-fundamental-headers.patch
	06-add-missing-byteorder-headers.patch
	07-fix-compiler-headers.patch
	08-fix-asm-offsets-simple.patch
	09-fix-memory-and-const.patch
	10-add-gcc15-conservative-flags.patch
	11-fix-irq-timer-definitions-v2.patch
	12-fix-proc-v7-assembly.patch
	13-fix-bool-redefinitions.patch
	14-fix-fs-build-errors.patch
	15-ultimate-macro-redefinition-fix.patch
	16-fix-ext4-strncpy-warnings.patch
	17-fix-devicetable-offsets-final.patch
"
builddir="$srcdir/android_kernel_samsung_msm8226-$_commit"

_log() {
    printf "\n[*] %s\n" "$1"
}

_die() {
    _log "ERRO: $1"
    exit 1
}

_detect_cross_compiler() {
    _log "Detectando compilador cruzado disponível..."

    # Lista de compiladores em ordem de preferência
    local compilers="armv7-alpine-linux-musleabihf-gcc arm-linux-gnueabihf-gcc arm-none-eabi-gcc"

    for compiler in $compilers; do
        _log "Verificando $compiler..."
        if command -v "$compiler" >/dev/null 2>&1; then
            export CROSS_COMPILE="${compiler%-gcc}-"
            _log "Compilador encontrado: $compiler"
            _log "CROSS_COMPILE definido como: $CROSS_COMPILE"
            return 0
        fi
    done

    _die "Nenhum compilador cruzado ARM encontrado!"
}

_setup_clean_environment() {
    _log "Configurando ambiente básico para compilação..."

    # Limpar variáveis que podem interferir
    unset LDFLAGS CPPFLAGS CFLAGS CXXFLAGS KCFLAGS AFLAGS KBUILD_AFLAGS
    unset KBUILD_CFLAGS EXTRA_CFLAGS KBUILD_CPPFLAGS KBUILD_LDFLAGS
    unset GCC_SPECS SPECS

    # Configurações básicas obrigatórias
    export ARCH=arm
    export SUBARCH=arm

    # Host compiler básico
    export HOSTCC="gcc"
    export HOSTCFLAGS="-O1 -w"

    # Versões do kernel
    export KERNELRELEASE="3.4.113"
    export UTS_RELEASE="3.4.113"
    export LOCALVERSION=""

    # Flags básicas e seguras para GCC moderno com kernel antigo
    export KBUILD_CFLAGS="-w -Wno-error -std=gnu89"
    export EXTRA_CFLAGS="-w -Wno-error"

    _log "Ambiente básico configurado"
}

_configure_advanced_linking() {
    _log "Configurando linking simplificado para kernel..."

    # SIMPLIFICADO: Usar apenas o linker padrão do cross-compile
    # Deixar o kernel build system escolher o melhor método

    # Apenas definir algumas flags básicas se necessário
    export LDFLAGS_vmlinux=""

    # Verificar se ld.bfd está disponível como alternativa
    if command -v "${CROSS_COMPILE}ld.bfd" >/dev/null 2>&1; then
        _log "ld.bfd disponível como alternativa"
    fi

    _log "Linking configurado com configuração padrão"
}

_fix_gcc14_compatibility() {
    _log "Aplicando correção para compatibilidade com GCC 14..."

    # Criar o arquivo compiler-gcc14.h necessário
    mkdir -p include/linux
    cat > include/linux/compiler-gcc14.h << 'EOF'
#ifndef __LINUX_COMPILER_H
#error "Please do not include <linux/compiler-gcc14.h> directly, include <linux/compiler.h> instead."
#endif

#define __used			__attribute__((__used__))
#define __must_check		__attribute__((warn_unused_result))
#define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
#define __cold			__attribute__((__cold__))
#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)

#ifndef __CHECKER__
# define __compiletime_warning(message) __attribute__((warning(message)))
# define __compiletime_error(message) __attribute__((error(message)))
#endif

#define unreachable() __builtin_unreachable()
#define __noclone	__attribute__((__noclone__))
#define __visible __attribute__((externally_visible))
#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)

#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
#define __HAVE_BUILTIN_BSWAP32__
#define __HAVE_BUILTIN_BSWAP64__
#define __HAVE_BUILTIN_BSWAP16__
#endif

#if GCC_VERSION >= 40902
#define __no_sanitize_address __attribute__((no_sanitize_address))
#endif
EOF

    if [ -f include/linux/compiler-gcc14.h ]; then
        _log "Arquivo compiler-gcc14.h criado com sucesso"
        ls -la include/linux/compiler-gcc14.h
    else
        _log "ERRO: Falha ao criar compiler-gcc14.h"
        return 1
    fi
}

_fix_devicetable_offsets_ultimate() {
    _log "Aplicando correção DEFINITIVA para devicetable-offsets.c..."

    # Criar diretório se não existir
    mkdir -p scripts/mod

    # Criar arquivo devicetable-offsets.c COMPLETO e funcional
    cat > scripts/mod/devicetable-offsets.c << 'EOF'
#include <linux/kbuild.h>
#include <linux/types.h>
#include <linux/mod_devicetable.h>

/* Definir tipos básicos necessários */
#ifndef __u8
typedef unsigned char __u8;
#endif
#ifndef __u16
typedef unsigned short __u16;
#endif
#ifndef __u32
typedef unsigned int __u32;
#endif
#ifndef kernel_ulong_t
typedef unsigned long kernel_ulong_t;
#endif

/* Definir constantes necessárias */
#ifndef BITS_PER_LONG
#define BITS_PER_LONG 32
#endif

#ifndef INPUT_DEVICE_ID_EV_MAX
#define INPUT_DEVICE_ID_EV_MAX 0x1f
#endif

#ifndef INPUT_DEVICE_ID_KEY_MAX
#define INPUT_DEVICE_ID_KEY_MAX 0x2ff
#endif

#ifndef INPUT_DEVICE_ID_REL_MAX
#define INPUT_DEVICE_ID_REL_MAX 0x0f
#endif

#ifndef INPUT_DEVICE_ID_ABS_MAX
#define INPUT_DEVICE_ID_ABS_MAX 0x3f
#endif

#ifndef INPUT_DEVICE_ID_MSC_MAX
#define INPUT_DEVICE_ID_MSC_MAX 0x07
#endif

#ifndef INPUT_DEVICE_ID_LED_MAX
#define INPUT_DEVICE_ID_LED_MAX 0x0f
#endif

#ifndef INPUT_DEVICE_ID_SND_MAX
#define INPUT_DEVICE_ID_SND_MAX 0x07
#endif

#ifndef INPUT_DEVICE_ID_FF_MAX
#define INPUT_DEVICE_ID_FF_MAX 0x7f
#endif

#ifndef INPUT_DEVICE_ID_SW_MAX
#define INPUT_DEVICE_ID_SW_MAX 0x0f
#endif

/* Definir DEVID para estruturas simples */
#define DEVID(devid) DEFINE(SIZE_##devid, sizeof(struct devid))

/* Definir DEVID_FIELD usando offset manual calculado */
#define DEVID_FIELD(devid, field) DEFINE(OFF_##devid##_##field, __builtin_offsetof(struct devid, field))

int main(void)
{
    /* PCI device */
    DEVID(pci_device_id);
    DEVID_FIELD(pci_device_id, vendor);
    DEVID_FIELD(pci_device_id, device);
    DEVID_FIELD(pci_device_id, subvendor);
    DEVID_FIELD(pci_device_id, subdevice);
    DEVID_FIELD(pci_device_id, class);
    DEVID_FIELD(pci_device_id, class_mask);

    /* USB device */
    DEVID(usb_device_id);
    DEVID_FIELD(usb_device_id, match_flags);
    DEVID_FIELD(usb_device_id, idVendor);
    DEVID_FIELD(usb_device_id, idProduct);
    DEVID_FIELD(usb_device_id, bcdDevice_lo);
    DEVID_FIELD(usb_device_id, bcdDevice_hi);
    DEVID_FIELD(usb_device_id, bDeviceClass);
    DEVID_FIELD(usb_device_id, bDeviceSubClass);
    DEVID_FIELD(usb_device_id, bDeviceProtocol);
    DEVID_FIELD(usb_device_id, bInterfaceClass);
    DEVID_FIELD(usb_device_id, bInterfaceSubClass);
    DEVID_FIELD(usb_device_id, bInterfaceProtocol);
    DEVID_FIELD(usb_device_id, bInterfaceNumber);

    /* HID device */
    DEVID(hid_device_id);
    DEVID_FIELD(hid_device_id, bus);
    DEVID_FIELD(hid_device_id, group);
    DEVID_FIELD(hid_device_id, vendor);
    DEVID_FIELD(hid_device_id, product);

    /* Input device - com tratamento especial para arrays */
    DEVID(input_device_id);
    DEVID_FIELD(input_device_id, flags);
    DEVID_FIELD(input_device_id, bustype);
    DEVID_FIELD(input_device_id, vendor);
    DEVID_FIELD(input_device_id, product);
    DEVID_FIELD(input_device_id, version);
    DEVID_FIELD(input_device_id, evbit);
    DEVID_FIELD(input_device_id, keybit);
    DEVID_FIELD(input_device_id, relbit);
    DEVID_FIELD(input_device_id, absbit);
    DEVID_FIELD(input_device_id, mscbit);
    DEVID_FIELD(input_device_id, ledbit);
    DEVID_FIELD(input_device_id, sndbit);
    DEVID_FIELD(input_device_id, ffbit);
    DEVID_FIELD(input_device_id, swbit);

    /* Platform device */
    DEVID(platform_device_id);
    DEVID_FIELD(platform_device_id, name);

    /* I2C device */
    DEVID(i2c_device_id);
    DEVID_FIELD(i2c_device_id, name);

    /* SPI device */
    DEVID(spi_device_id);
    DEVID_FIELD(spi_device_id, name);

    /* DMI system */
    DEVID(dmi_system_id);
    DEVID_FIELD(dmi_system_id, matches);

    /* MDIO device */
    DEVID(mdio_device_id);
    DEVID_FIELD(mdio_device_id, phy_id);
    DEVID_FIELD(mdio_device_id, phy_id_mask);

    /* Zorro device */
    DEVID(zorro_device_id);
    DEVID_FIELD(zorro_device_id, id);

    /* ISA PnP device */
    DEVID(isapnp_device_id);
    DEVID_FIELD(isapnp_device_id, vendor);
    DEVID_FIELD(isapnp_device_id, function);

    /* AMBA device */
    DEVID(amba_id);
    DEVID_FIELD(amba_id, id);
    DEVID_FIELD(amba_id, mask);

    /* x86 CPU */
    DEVID(x86_cpu_id);
    DEVID_FIELD(x86_cpu_id, feature);
    DEVID_FIELD(x86_cpu_id, family);
    DEVID_FIELD(x86_cpu_id, model);
    DEVID_FIELD(x86_cpu_id, vendor);

    /* OF device */
    DEVID(of_device_id);
    DEVID_FIELD(of_device_id, name);
    DEVID_FIELD(of_device_id, type);
    DEVID_FIELD(of_device_id, compatible);

    /* VirtIO device */
    DEVID(virtio_device_id);
    DEVID_FIELD(virtio_device_id, device);
    DEVID_FIELD(virtio_device_id, vendor);

    /* VMBus device */
    DEVID(hv_vmbus_device_id);
    DEVID_FIELD(hv_vmbus_device_id, guid);

    /* Definições condicionais para dispositivos que podem não existir */
#ifdef CONFIG_IEEE1394
    DEVID(ieee1394_device_id);
    DEVID_FIELD(ieee1394_device_id, match_flags);
    DEVID_FIELD(ieee1394_device_id, vendor_id);
    DEVID_FIELD(ieee1394_device_id, model_id);
    DEVID_FIELD(ieee1394_device_id, specifier_id);
    DEVID_FIELD(ieee1394_device_id, version);
#else
    /* Definições vazias para evitar erros */
    DEFINE(SIZE_ieee1394_device_id, 0);
#endif

#ifdef CONFIG_CCW
    DEVID(ccw_device_id);
    DEVID_FIELD(ccw_device_id, match_flags);
    DEVID_FIELD(ccw_device_id, cu_type);
    DEVID_FIELD(ccw_device_id, cu_model);
    DEVID_FIELD(ccw_device_id, dev_type);
    DEVID_FIELD(ccw_device_id, dev_model);
#else
    DEFINE(SIZE_ccw_device_id, 0);
#endif

#ifdef CONFIG_ZCRYPT
    DEVID(ap_device_id);
    DEVID_FIELD(ap_device_id, dev_type);
#else
    DEFINE(SIZE_ap_device_id, 0);
#endif

#ifdef CONFIG_CSS
    DEVID(css_device_id);
    DEVID_FIELD(css_device_id, type);
#else
    DEFINE(SIZE_css_device_id, 0);
#endif

#ifdef CONFIG_SERIO
    DEVID(serio_device_id);
    DEVID_FIELD(serio_device_id, type);
    DEVID_FIELD(serio_device_id, proto);
    DEVID_FIELD(serio_device_id, id);
    DEVID_FIELD(serio_device_id, extra);
#else
    DEFINE(SIZE_serio_device_id, 0);
#endif

#ifdef CONFIG_ACPI
    DEVID(acpi_device_id);
    DEVID_FIELD(acpi_device_id, id);
#else
    DEFINE(SIZE_acpi_device_id, 0);
#endif

#ifdef CONFIG_PNP
    DEVID(pnp_device_id);
    DEVID_FIELD(pnp_device_id, id);
    DEVID(pnp_card_device_id);
    DEVID_FIELD(pnp_card_device_id, devs);
#else
    DEFINE(SIZE_pnp_device_id, 0);
    DEFINE(SIZE_pnp_card_device_id, 0);
#endif

#ifdef CONFIG_PCMCIA
    DEVID(pcmcia_device_id);
    DEVID_FIELD(pcmcia_device_id, match_flags);
    DEVID_FIELD(pcmcia_device_id, manf_id);
    DEVID_FIELD(pcmcia_device_id, card_id);
    DEVID_FIELD(pcmcia_device_id, func_id);
    DEVID_FIELD(pcmcia_device_id, function);
    DEVID_FIELD(pcmcia_device_id, device_no);
    DEVID_FIELD(pcmcia_device_id, prod_id_hash);
#else
    DEFINE(SIZE_pcmcia_device_id, 0);
#endif

#ifdef CONFIG_VIO
    DEVID(vio_device_id);
    DEVID_FIELD(vio_device_id, type);
    DEVID_FIELD(vio_device_id, compat);
#else
    DEFINE(SIZE_vio_device_id, 0);
#endif

#ifdef CONFIG_EISA
    DEVID(eisa_device_id);
    DEVID_FIELD(eisa_device_id, sig);
#else
    DEFINE(SIZE_eisa_device_id, 0);
#endif

#ifdef CONFIG_PARISC
    DEVID(parisc_device_id);
    DEVID_FIELD(parisc_device_id, hw_type);
    DEVID_FIELD(parisc_device_id, hversion);
    DEVID_FIELD(parisc_device_id, hversion_rev);
    DEVID_FIELD(parisc_device_id, sversion);
#else
    DEFINE(SIZE_parisc_device_id, 0);
#endif

#ifdef CONFIG_MMC
    DEVID(sdio_device_id);
    DEVID_FIELD(sdio_device_id, class);
    DEVID_FIELD(sdio_device_id, vendor);
    DEVID_FIELD(sdio_device_id, device);
#else
    DEFINE(SIZE_sdio_device_id, 0);
#endif

#ifdef CONFIG_SSB
    DEVID(ssb_device_id);
    DEVID_FIELD(ssb_device_id, vendor);
    DEVID_FIELD(ssb_device_id, coreid);
    DEVID_FIELD(ssb_device_id, revision);
#else
    DEFINE(SIZE_ssb_device_id, 0);
#endif

#ifdef CONFIG_BCMA
    DEVID(bcma_device_id);
    DEVID_FIELD(bcma_device_id, manuf);
    DEVID_FIELD(bcma_device_id, id);
    DEVID_FIELD(bcma_device_id, rev);
    DEVID_FIELD(bcma_device_id, class);
#else
    DEFINE(SIZE_bcma_device_id, 0);
#endif

    return 0;
}
EOF

    _log "Arquivo devicetable-offsets.c criado com definições completas"

    # Verificar se o arquivo foi criado corretamente
    if [ -f scripts/mod/devicetable-offsets.c ]; then
        local line_count=$(wc -l < scripts/mod/devicetable-offsets.c)
        _log "Arquivo criado com $line_count linhas"

        # Verificar se não contém offsetof (que causa problemas)
        if grep -q "offsetof(" scripts/mod/devicetable-offsets.c; then
            _log "ATENÇÃO: Arquivo contém offsetof - mas está usando __builtin_offsetof que deve funcionar"
        else
            _log "Arquivo não contém offsetof direto - perfeito!"
        fi
    else
        _die "Falha ao criar devicetable-offsets.c"
    fi
}

_fix_printf_macro_bug() {
    _log "Corrigindo problema com macro __printf..."

    # O erro está no include/asm-generic/bug.h que está tentando usar __printf
    # Vamos corrigir definindo a macro antes

    # Primeiro, verificar se o arquivo existe e contém o problema
    if [ -f include/asm-generic/bug.h ]; then
        if grep -q "__printf(3, 4)" include/asm-generic/bug.h; then
            _log "Problema __printf detectado em bug.h, aplicando correção..."

            # Fazer backup
            cp include/asm-generic/bug.h include/asm-generic/bug.h.bak

            # Adicionar definição de __printf no topo do arquivo se não existir
            if ! grep -q "#define __printf" include/asm-generic/bug.h; then
                sed -i '1i\
#ifndef __printf\
#define __printf(a,b) __attribute__((format(printf,a,b)))\
#endif' include/asm-generic/bug.h

                _log "__printf definido em bug.h"
            fi
        fi
    fi

    # Também verificar e corrigir em outros locais comuns
    for header_file in include/linux/compiler.h include/linux/compiler-gcc*.h; do
        if [ -f "$header_file" ] && ! grep -q "#define __printf" "$header_file"; then
            sed -i '1i\
#ifndef __printf\
#define __printf(a,b) __attribute__((format(printf,a,b)))\
#endif' "$header_file" 2>/dev/null || true
        fi
    done
}

prepare() {
    cd "$builddir"
    _log "Preparando kernel com correções completas..."

    # Passo 1: Detectar compilador
    _detect_cross_compiler

    # Passo 2: Configurar ambiente básico
    _setup_clean_environment

    # Passo 3: Configurar linking
    _configure_advanced_linking

    # PASSO CRÍTICO 1: Corrigir compatibilidade GCC 14
    _fix_gcc14_compatibility

    # PASSO CRÍTICO 2: Corrigir problema __printf ANTES de aplicar patches
    _fix_printf_macro_bug

    # Passo 4: Aplicar patches básicos
    _log "Aplicando patches essenciais..."
    local patch_count=0
    local patch_success=0

    for patch in $(echo "$source" | tr ' ' '\n' | grep '\.patch$' | sort); do
        if [ -f "$srcdir/$patch" ]; then
            patch_count=$((patch_count + 1))
            if patch -p1 -i "$srcdir/$patch" >/dev/null 2>&1; then
                patch_success=$((patch_success + 1))
                _log "Patch $patch aplicado"
            else
                _log "Patch $patch falhou - continuando"
            fi
        fi
    done
    _log "Patches aplicados: $patch_success/$patch_count"

    # PASSO CRÍTICO 3: Corrigir devicetable-offsets.c COMPLETAMENTE
    _fix_devicetable_offsets_ultimate

    # Passo 5: Aplicar configuração do dispositivo
    if [ -f "$srcdir/config-samsung-matisse3g.armv7" ]; then
        _log "Aplicando configuração do dispositivo..."
        cp "$srcdir/config-samsung-matisse3g.armv7" .config
    else
        _die "Configuração do dispositivo não encontrada!"
    fi

    # Passo 6: Criar estruturas básicas
    mkdir -p include/generated include/config scripts/basic

    # Passo 7: Arquivos obrigatórios
    echo '#define UTS_RELEASE "3.4.113"' > include/generated/utsrelease.h
    echo '/* Auto generated */' > include/generated/autoconf.h
    touch include/generated/bounds.h include/generated/asm-offsets.h

    # Passo 8: Preparar build básico
    _log "Preparando ferramentas básicas..."
    make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" scripts_basic >/dev/null 2>&1 || _log "AVISO: scripts_basic parcial"

    # Passo 9: Configuração final
    _log "Configuração final..."
    yes "" | make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" oldconfig >/dev/null 2>&1 || _log "AVISO: oldconfig parcial"

    _log "Preparação completa concluída com correções para devicetable-offsets"
}

build() {
    cd "$builddir"
    _log "Compilando kernel com todas as correções aplicadas..."

    # Verificar estado das correções
    _log "=== VERIFICAÇÃO PRÉ-BUILD ==="

    # 1. Verificar GCC 14
    if [ -f include/linux/compiler-gcc14.h ]; then
        _log "✓ Correção GCC 14 presente"
    else
        _log "✗ Correção GCC 14 ausente - recriando"
        _fix_gcc14_compatibility
    fi

    # 2. Verificar devicetable-offsets
    if [ -f scripts/mod/devicetable-offsets.c ]; then
        local lines=$(wc -l < scripts/mod/devicetable-offsets.c)
        _log "✓ devicetable-offsets.c presente ($lines linhas)"
    else
        _log "✗ devicetable-offsets.c ausente - recriando"
        _fix_devicetable_offsets_ultimate
    fi

    # 3. Verificar __printf
    if grep -q "#define __printf" include/asm-generic/bug.h 2>/dev/null; then
        _log "✓ Correção __printf aplicada"
    else
        _log "⚠ Correção __printf pode estar ausente"
    fi

    # Verificar configuração ARMv7
    if grep -q "CONFIG_CPU_V7=y" .config 2>/dev/null; then
        _log "✓ Configuração ARMv7 confirmada"
    else
        _log "⚠ Configuração ARMv7 não detectada"
    fi

    # Proteger arquivos críticos
    if [ -f include/generated/utsrelease.h ]; then
        chmod 444 include/generated/utsrelease.h
    fi

    _log "=== INICIANDO COMPILAÇÃO ==="

    # Compilação com timeout e flags otimizadas
    if ! timeout 3600 make \
         ARCH=arm \
         CROSS_COMPILE="$CROSS_COMPILE" \
         HOSTCC="$HOSTCC" \
         HOSTCFLAGS="$HOSTCFLAGS" \
         KBUILD_CFLAGS="$KBUILD_CFLAGS" \
         EXTRA_CFLAGS="$EXTRA_CFLAGS" \
         V=1 \
         -j$(nproc) zImage 2>&1 | tee build.log; then

        _log "Compilação falhou. Analisando erro..."

        # Análise detalhada do erro
        if grep -q "__printf.*expected declaration specifiers" build.log; then
            _log "ERRO: Ainda problema com __printf macro"
            echo "=== PROBLEMA __printf ==="
            grep -B2 -A2 "__printf" build.log | head -10
        elif grep -q "OFF_.*_undeclared" build.log; then
            _log "ERRO: Ainda problema com device table offsets"
            echo "=== PROBLEMA DEVICE TABLE ==="
            grep -B2 -A2 "OFF_.*undeclared" build.log | head -10
        elif grep -q "SMP not supported" build.log; then
            _log "ERRO: Problema de arquitetura ARM"
        else
            _log "NOVO TIPO DE ERRO - PROGRESSO!"
            echo "=== NOVO ERRO ==="
            grep -E "error:|Error:|fatal error:" build.log | head -5
        fi

        echo "=== CONTEXTO COMPLETO DO ERRO ==="
        grep -B3 -A3 "error:" build.log | head -20
        _die "Falha na compilação - verifique build.log"
    fi

    # Verificar se zImage foi criado
    if [ ! -f arch/arm/boot/zImage ]; then
        _die "zImage não foi criado"
    fi

    local zimage_size=$(stat -c%s arch/arm/boot/zImage 2>/dev/null || echo "0")
    _log "zImage criado com sucesso! Tamanho: $zimage_size bytes"

    # Módulos (não-crítico)
    _log "Compilando módulos..."
    make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" \
         KBUILD_CFLAGS="$KBUILD_CFLAGS" EXTRA_CFLAGS="$EXTRA_CFLAGS" \
         V=0 -j$(nproc) modules >/dev/null 2>&1 || _log "Módulos falharam (não-crítico)"

    _log "Compilação concluída com sucesso!"
}

package() {
    cd "$builddir"
    _log "Empacotando kernel..."

    # Instalar kernel
    install -Dm644 arch/arm/boot/zImage "$pkgdir/boot/vmlinuz-$_flavor"

    # Instalar módulos (se existirem)
    make DESTDIR="$pkgdir" INSTALL_MOD_PATH="$pkgdir" \
         ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" \
         modules_install 2>/dev/null || _log "AVISO: Instalação de módulos falhou"

    # Instalar DTBs (se existirem)
    if [ -d arch/arm/boot/dts ]; then
        dtb_count=$(find arch/arm/boot/dts -name "*.dtb" 2>/dev/null | wc -l)
        if [ "$dtb_count" -gt 0 ]; then
            mkdir -p "$pkgdir/boot/dtbs-$_flavor"
            find arch/arm/boot/dts -name "*.dtb" -exec cp {} "$pkgdir/boot/dtbs-$_flavor/" \; 2>/dev/null
            _log "Instalados $dtb_count DTBs"
        fi
    fi

    # Criar symlink
    mkdir -p "$pkgdir/boot"
    ln -sf "vmlinuz-$_flavor" "$pkgdir/boot/vmlinuz" || true

    _log "Empacotamento concluído"
}

sha512sums="
7fa4253037e154e2f245e12b4d7999887d6fcf99c9e7d30601ecf53a2fe5d47f1a423dd9483dac9eec86b7e5a9daf0b48e8ddde7311cd091a66630ff0656bd45  linux-samsung-matisse3g-pmos-matisse3g-fixes.tar.gz
4eff4dab705a03c3ce5082b00469b1d8728f6cda27a5e79786cc9bdb299f8421d016c74b0aa3e3da39e6849ac39d962b5a11aa7794ba18c5a376161447147c31  config-samsung-matisse3g.armv7
f3bbc54d1c3433310f701c0da130c165d8baab29d924ad90a7021c40818e767066c10b6c2467b97d92b43191a7d0e1bb389dc056463263c14347e9e4582ae0ca  01-fix-timex-header.patch
726321e16d16edad715abd4bc83e9f546902e11b5d2c5f5ab1b7076872ad0fceee85d2e512e8007a78c0a956b3454b239b9a844149a87094a342d91030972889  03-fix-defconfig.patch
7462871c23903b5b061117757adb82da2e80caeadf44f941686ca1bba8c67a337d5d1ffdf94350cdd964ecc7651adec6770cc0801e18e60872b72490e917fa02  04-fix-jffs2-format-warnings.patch
ce5dd92a66e208c873919aea7f571b72bd7811482b7f846d9bb62e22da5eb7671e941168fc413ee87e2e434d96799843f3a5690789c460651d7120d72dfaf3e3  05-fix-fundamental-headers.patch
9cdd95f4701f1f659fdeb9aa51529d71c5f0102f6422cfbc6ef1d37b5f6071515be816bf825c7d84ed4fa118c26dc1871aed5a7721e64fb73db8ed5803f65581  06-add-missing-byteorder-headers.patch
ea9fd7ed6e4ad9f51cf8f852cabe13fe6d725f77f04cb9aff584844156f6355ac55aafed6ae6cfc94cc032c15830057867a08ce1acf2e4985aed8bba4010b132  07-fix-compiler-headers.patch
c0567e7c8f8458663296a6bdddac021dd8417055f2f17fa96c13ce39cf6502fffa23897eecac9911fce515f4f7f716d0ff394334fe6a36036c67832c378e0f43  08-fix-asm-offsets-simple.patch
7486b8f2841205e9988719a7cff4508965bd6b5808c57ab0ac3f31cdcdf297234cd3b7ab703c142513bca699d024026577ebbe720e8c2187d821a68808e86cd5  09-fix-memory-and-const.patch
c100588d2c68d4ca7564cfc5dfabe55d0ffef60d6d4bf3561b551db851ce472951ef3521ea2cad5099c65137bc230a5f17aaff81f95486ab8a0ff602114e6a24  10-add-gcc15-conservative-flags.patch
7380d8e468c4183230871ebc38cc5ef853adb59683774e7a7ced7430ee12bf5091b003197aa5af4028ddfc731e1b921f27e5e2e357023bb0ac82918d73fc612a  11-fix-irq-timer-definitions-v2.patch
235a13b089f624f65cf3533c8480fad10bc76bb322a2cdae93ca68115e3eb52a58a97b3dd2ee89cceb79185451d3a8599562d6188c2d172479e2a43846c51bdf  12-fix-proc-v7-assembly.patch
6d881eb39c17e38b829c8568bcb98960ef570a709731c6b3327c5130c3181cdc555adbd6bb3915a8d6d377c9268e1cc790a78a3a10b682a20d05ea9425f27721  13-fix-bool-redefinitions.patch
bcaf48edc68de62aeae3c97c0419ae7e78ac3d65ced9d08cb1d397561bc546de9f632c1f398c7b04a4f8326ea01238f3204efdd1f96db860f32122a96c2736d1  14-fix-fs-build-errors.patch
b31c13237d0f45bc9649be5915d0d37a9d40d3063d53f49b874481cb517d1bb5038af5071470f43ce07b160dcc2df60a65344bc49f9131ccaddab0dc4d55cdce  15-ultimate-macro-redefinition-fix.patch
068a2b50a9125c8cc23897910edffa3b08fdab5e082679e90937b9f984da8fb3b99d9a415fac9314cfeba85e9729bc0405875627a3b01aa36dfbe2a7f8821de2  16-fix-ext4-strncpy-warnings.patch
b879c8401e1c96a333e6cedb551a678562f4e349eb9c2526bb8111bb0e3c05d84e50722bbe24a356a0fd3386073760c911200f8a47804fd809d27aa3b15f9b52  17-fix-devicetable-offsets-final.patch
"
