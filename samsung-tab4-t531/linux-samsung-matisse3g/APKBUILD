# Maintainer: Felipe Prestes Aranalde <felipe.aranalde@gmail.com>
pkgname=linux-samsung-matisse3g
pkgver=3.4.113
pkgrel=75
pkgdesc="Kernel Linux para Samsung Galaxy Tab 4 10.1 (SM-T531) - Fix struct proc_info_list"
arch="armv7"
_flavor="samsung-matisse3g"
url="https://github.com/felipeflskater/android_kernel_samsung_msm8226"
license="GPL-2.0-only"
options="!strip !check !tracedeps pmb:cross-native"
makedepends="bash bc bison devicepkg-dev dtbtool elfutils-dev findutils flex gmp-dev installkernel linux-headers mpc1-dev mpfr-dev perl python3 sed xz gcc-arm-none-eabi"

_commit="pmos-matisse3g-fixes"

source="
	$pkgname-$_commit.tar.gz::https://github.com/Felipeflskater/android_kernel_samsung_msm8226/archive/refs/heads/$_commit.tar.gz
	config-samsung-matisse3g.armv7
	01-fix-timex-header.patch
	03-fix-defconfig.patch
	04-fix-jffs2-format-warnings.patch
	05-fix-fundamental-headers.patch
	06-add-missing-byteorder-headers.patch
	07-fix-compiler-headers.patch
	08-fix-asm-offsets-simple.patch
	09-fix-memory-and-const.patch
	10-add-gcc15-conservative-flags.patch
	11-fix-irq-timer-definitions-v2.patch
	12-fix-proc-v7-assembly.patch
	13-fix-bool-redefinitions.patch
	14-fix-fs-build-errors.patch
	15-ultimate-macro-redefinition-fix.patch
	16-fix-ext4-strncpy-warnings.patch
	22-ultimate-all-offsets-final.patch
	23-fix-arm-architecture-detection.patch
	24-fix-devicetable-basic-types.patch
	25-fix-printf-macro.patch
	26-fix-string-header-inclusion.patch
	27-fix-fundamental-types-comprehensive.patch
"
builddir="$srcdir/android_kernel_samsung_msm8226-$_commit"

prepare() {
    cd "$builddir"

    # Compilador
    for comp in armv7-alpine-linux-musleabihf-gcc arm-linux-gnueabihf-gcc arm-none-eabi-gcc; do
        if command -v "$comp" >/dev/null 2>&1; then
            export CROSS_COMPILE="${comp%-gcc}-"
            break
        fi
    done
    [ -z "$CROSS_COMPILE" ] && { echo "ERRO: Compilador não encontrado"; exit 1; }

    # Ambiente - Mais agressivo para evitar conflitos
    unset LDFLAGS CPPFLAGS CFLAGS CXXFLAGS KCFLAGS AFLAGS KBUILD_AFLAGS KBUILD_CFLAGS EXTRA_CFLAGS KBUILD_CPPFLAGS KBUILD_LDFLAGS
    export ARCH=arm SUBARCH=arm HOSTCC=gcc
    export HOSTCFLAGS="-O1 -w -std=gnu89 -D__LINUX_ARM_ARCH__=7 -DBITS_PER_LONG=32"
    export KBUILD_CFLAGS="-w -Wno-error -std=gnu89 -D__LINUX_ARM_ARCH__=7 -DBITS_PER_LONG=32"
    export EXTRA_CFLAGS="-w -Wno-error -D__LINUX_ARM_ARCH__=7 -DBITS_PER_LONG=32"
    export KBUILD_CPPFLAGS="-D__LINUX_ARM_ARCH__=7 -DBITS_PER_LONG=32"

    # Criar estruturas básicas
    mkdir -p include/linux include/asm-generic include/generated include/config scripts/basic scripts/mod

    # Headers ARM-específicos primeiro
    mkdir -p arch/arm/include/mach arch/arm/include/generated/mach arch/arm/include/generated/asm

    # INÍCIO DOS ARQUIVOS HEADER - types.h
    cat << 'TYPES_EOF' > include/linux/types.h
#ifndef _LINUX_TYPES_H
#define _LINUX_TYPES_H

#ifndef __ASSEMBLY__

typedef unsigned char u8;
typedef signed char s8;
typedef unsigned short u16;
typedef signed short s16;
typedef unsigned int u32;
typedef signed int s32;
typedef unsigned long long u64;
typedef signed long long s64;

typedef u8 __u8;
typedef s8 __s8;
typedef u16 __u16;
typedef s16 __s16;
typedef u32 __u32;
typedef s32 __s32;
typedef u64 __u64;
typedef s64 __s64;

#ifndef __SIZE_TYPE__
#define __SIZE_TYPE__ unsigned long
#endif

typedef unsigned long kernel_ulong_t;
typedef __SIZE_TYPE__ __kernel_size_t;
typedef long __kernel_ssize_t;
typedef long __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef int __kernel_pid_t;
typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;
typedef unsigned long __kernel_ino_t;
typedef unsigned int __kernel_mode_t;
typedef unsigned short __kernel_umode_t;
typedef long long __kernel_loff_t;
typedef unsigned int __kernel_dev_t;

typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_ptrdiff_t ptrdiff_t;
typedef __kernel_time_t time_t;
typedef __kernel_mode_t umode_t;
typedef unsigned int dev_t;
typedef unsigned int gfp_t;
typedef long clock_t;
typedef unsigned long resource_size_t;
typedef unsigned long phys_addr_t;
typedef int clockid_t;
typedef unsigned char bool;

#ifndef true
#define true 1
#endif
#ifndef false
#define false 0
#endif

typedef struct {
    int counter;
} atomic_t;

struct list_head {
    struct list_head *next, *prev;
};

struct hlist_head {
    struct hlist_node *first;
};

struct hlist_node {
    struct hlist_node *next, **pprev;
};

#ifdef __KERNEL__

#define __bitwise__
#ifdef __CHECK_ENDIAN__
#define __bitwise __bitwise__
#else
#define __bitwise
#endif

typedef __u16 __bitwise __le16;
typedef __u16 __bitwise __be16;
typedef __u32 __bitwise __le32;
typedef __u32 __bitwise __be32;
typedef __u64 __bitwise __le64;
typedef __u64 __bitwise __be64;

typedef __u16 __bitwise __sum16;
typedef __u32 __bitwise __wsum;

#endif

#define DECLARE_BITMAP(name,bits) unsigned long name[BITS_TO_LONGS(bits)]

#ifndef BITS_PER_LONG
#define BITS_PER_LONG 32
#endif

#define BITS_TO_LONGS(nr) (((nr) + BITS_PER_LONG - 1) / BITS_PER_LONG)

typedef struct wait_queue wait_queue_t;
typedef struct wait_queue_head wait_queue_head_t;

#define NSEC_PER_USEC   1000L
#define NSEC_PER_MSEC   1000000L
#define USEC_PER_MSEC   1000L
#define NSEC_PER_SEC    1000000000L
#define USEC_PER_SEC    1000000L
#define MSEC_PER_SEC    1000L
#define FSEC_PER_SEC    1000000000000000LL

#endif

#endif
TYPES_EOF

    # stddef.h - simples, sem inclusões circulares
    cat << 'STDDEF_EOF' > include/linux/stddef.h
#ifndef _LINUX_STDDEF_H
#define _LINUX_STDDEF_H

#undef NULL
#if defined(__cplusplus)
#define NULL 0
#else
#define NULL ((void *)0)
#endif

#undef offsetof
#ifdef __compiler_offsetof
#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
#endif

#endif
STDDEF_EOF

    # string.h
    cat << 'STRING_EOF' > include/linux/string.h
#ifndef _LINUX_STRING_H_
#define _LINUX_STRING_H_

#include <linux/types.h>
#include <linux/stddef.h>

extern char * strcpy(char *,const char *);
extern char * strncpy(char *,const char *, __kernel_size_t);
extern __kernel_size_t strlen(const char *);
extern int strcmp(const char *,const char *);
extern int strncmp(const char *,const char *,__kernel_size_t);
extern char * strchr(const char *,int);
extern char * strrchr(const char *,int);
extern char * strstr(const char *,const char *);
extern void * memset(void *,int,__kernel_size_t);
extern void * memcpy(void *,const void *,__kernel_size_t);
extern void * memmove(void *,const void *,__kernel_size_t);
extern int memcmp(const void *,const void *,__kernel_size_t);
extern void * memchr(const void *,int,__kernel_size_t);

#endif
STRING_EOF

    # compiler-attributes.h
    cat << 'COMPILER_ATTR_EOF' > include/linux/compiler-attributes.h
#ifndef __LINUX_COMPILER_ATTRIBUTES_H
#define __LINUX_COMPILER_ATTRIBUTES_H

#ifdef __GNUC__
# define __printf(a, b) __attribute__((format(printf, a, b)))
# define __scanf(a, b)  __attribute__((format(scanf, a, b)))
# define __attribute_const__ __attribute__((__const__))
# define __maybe_unused __attribute__((unused))
#else
# define __printf(a, b)
# define __scanf(a, b)
# define __attribute_const__
# define __maybe_unused
#endif

#endif
COMPILER_ATTR_EOF

    # Headers ARM
    cat << 'MEMORY_EOF' > arch/arm/include/mach/memory.h
#ifndef __ASM_MACH_MEMORY_H
#define __ASM_MACH_MEMORY_H

#define PLAT_PHYS_OFFSET	UL(0x00000000)
#define MAX_DMA_ADDRESS		0x40000000

#endif
MEMORY_EOF

    # param.h
    cat << 'PARAM_EOF' > arch/arm/include/generated/asm/param.h
#ifndef _ASM_ARM_PARAM_H
#define _ASM_ARM_PARAM_H

#ifndef HZ
#define HZ 250
#endif

#define USER_HZ		100
#define CLOCKS_PER_SEC	(USER_HZ)

#ifndef EXEC_PAGESIZE
#define EXEC_PAGESIZE	4096
#endif

#ifndef NOGROUP
#define NOGROUP		(-1)
#endif

#define MAXHOSTNAMELEN	64

#endif
PARAM_EOF

    # GCC headers
    for v in 14 15 16; do
        cat << "GCC_EOF" > include/linux/compiler-gcc${v}.h
#ifndef __LINUX_COMPILER_H
#error "Include compiler.h"
#endif

#define __used __attribute__((__used__))
#define __must_check __attribute__((warn_unused_result))
#define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
#define __cold __attribute__((__cold__))
#define unreachable() __builtin_unreachable()
#define __noclone __attribute__((__noclone__, __optimize__("no-tracer")))
#define __visible __attribute__((externally_visible))
#define asm_volatile_goto(x...) do { asm goto(x); asm (""); } while (0)

#ifndef __printf
#define __printf(a, b) __attribute__((format(printf, a, b)))
#endif

#define __scanf(a, b) __attribute__((format(scanf, a, b)))
#define __attribute_const__ __attribute__((__const__))
#define __maybe_unused __attribute__((unused))
#define __always_inline inline __attribute__((always_inline))
#define __deprecated __attribute__((deprecated))
#define __packed __attribute__((packed))
#define __weak __attribute__((weak))
#define __alias(symbol) __attribute__((alias(#symbol)))
#define __pure __attribute__((pure))
#define __aligned(x) __attribute__((aligned(x)))
#define __user
#define __kernel
#define __safe
#define __force
#define __nocast
#define __iomem
#define __must_hold(x)
#define __acquires(x)
#define __releases(x)
#define __acquire(x) (void)0
#define __release(x) (void)0
#define __cond_lock(x,c) (c)
#define __percpu
#define __rcu
#define __private
#define __pmem
#define __chk_user_ptr(x) (void)0
#define __chk_io_ptr(x) (void)0
#define __builtin_warning(x, y...) (1)
#define __must_be_array(x) 0
#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))

GCC_EOF
    done

    # compiler.h principal
    cat << 'COMPILER_EOF' > include/linux/compiler.h
#ifndef __LINUX_COMPILER_H
#define __LINUX_COMPILER_H

#include <linux/compiler-attributes.h>

#ifdef __CHECKER__
# define __user		__attribute__((noderef, address_space(1)))
# define __kernel
# define __safe		__attribute__((safe))
# define __force	__attribute__((force))
# define __nocast	__attribute__((nocast))
# define __iomem	__attribute__((noderef, address_space(2)))
# define __must_hold(x)	__attribute__((context(x,1,1)))
# define __acquires(x)	__attribute__((context(x,0,1)))
# define __releases(x)	__attribute__((context(x,1,0)))
# define __acquire(x)	__context__(x,1)
# define __release(x)	__context__(x,-1)
# define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
# define __percpu	__attribute__((noderef, address_space(3)))
# define __rcu		__attribute__((noderef, address_space(4)))
# define __private	__attribute__((noderef))
#else
# define __rcu
# define __private
# define __pmem
# define __user
# define __kernel
# define __safe
# define __force
# define __nocast
# define __iomem
# define __chk_user_ptr(x) (void)0
# define __chk_io_ptr(x) (void)0
# define __builtin_warning(x, y...) (1)
# define __must_hold(x)
# define __acquires(x)
# define __releases(x)
# define __acquire(x) (void)0
# define __release(x) (void)0
# define __cond_lock(x,c) (c)
# define __percpu
# define __rcu
# define __private
# define __pmem
# define __must_be_array(x) 0
#endif

#ifdef __GNUC__
# if __GNUC__ >= 15
#  include <linux/compiler-gcc15.h>
# elif __GNUC__ >= 14
#  include <linux/compiler-gcc14.h>
# else
#  include <linux/compiler-gcc.h>
# endif
#else
# error Sorry, your compiler is too old/not recognized.
#endif

#ifndef __same_type
# define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))
#endif

#ifndef barrier
# define barrier() __memory_barrier()
#endif

#endif
COMPILER_EOF

    # Headers gerados básicos
    echo '#define UTS_RELEASE "3.4.113"' > include/generated/utsrelease.h
    echo '/* Auto generated */' > include/generated/autoconf.h
    echo '#define __LINUX_ARM_ARCH__ 7' >> include/generated/autoconf.h
    echo '#define BITS_PER_LONG 32' >> include/generated/autoconf.h
    echo '#define HZ 250' >> include/generated/autoconf.h
    echo '#define CLOCK_TICK_RATE 19200000' >> include/generated/autoconf.h

    # Headers vazios necessários
    touch include/generated/bounds.h
    echo '/* Empty asm-offsets.h */' > include/generated/asm-offsets.h

    # Fix para asm/procinfo.h - definir estrutura proc_info_list
    mkdir -p arch/arm/include/asm
    cat << 'PROCINFO_EOF' > arch/arm/include/asm/procinfo.h
#ifndef __ASM_PROCINFO_H
#define __ASM_PROCINFO_H

#ifndef __ASSEMBLY__

struct proc_info_list {
    unsigned int        cpu_val;
    unsigned int        cpu_mask;
    unsigned long       __cpu_mm_mmu_flags;
    unsigned long       __cpu_io_mmu_flags;
    unsigned long       __cpu_flush;
    const char          *arch_name;
    const char          *elf_name;
    unsigned int        elf_hwcap;
    const char          *cpu_name;
    struct processor    *proc;
    struct cpu_tlb_fns  *tlb;
    struct cpu_user_fns *user;
    struct cpu_cache_fns *cache;
};

#endif /* !__ASSEMBLY__ */

/* Definições para compatibilidade */
#define PROCINFO_INITFUNC 0x10
#define PROCINFO_MM_MMUFLAGS 0x08
#define PROCINFO_IO_MMUFLAGS 0x0C

#endif
PROCINFO_EOF

    cat << 'DEBUG_EOF' > arch/arm/include/generated/mach/debug-macro.S
/* Debug macro vazio para MSM8226 */
	.macro	addruart, rp, rv, tmp
	.endm

	.macro	senduart, rd, rx
	.endm

	.macro	busyuart, rd, rx
	.endm

	.macro	waituart, rd, rx
	.endm
DEBUG_EOF

    # Fix completo para devicetable-offsets.c
    cat << 'DEVICETABLE_EOF' > scripts/mod/devicetable-offsets.c
/* Fix fundamental para devicetable offsets */

/* Definir tipos básicos antes de qualquer coisa */
#ifndef __u8
typedef unsigned char __u8;
#endif
#ifndef __u16
typedef unsigned short __u16;
#endif
#ifndef __u32
typedef unsigned int __u32;
#endif
#ifndef __u64
typedef unsigned long long __u64;
#endif
#ifndef kernel_ulong_t
typedef unsigned long kernel_ulong_t;
#endif

#include <linux/kbuild.h>
#include <linux/stddef.h>
#include <linux/mod_devicetable.h>

/* Macros para calcular offsets manualmente */
#define MANUAL_OFFSET(type, field) ((unsigned long)&((type *)8)->field - 8)
#define DEVID(devid) DEFINE(SIZE_##devid, sizeof(struct devid))
#define DEVID_FIELD(devid, field) DEFINE(OFF_##devid##_##field, MANUAL_OFFSET(struct devid, field))
#define FAKE_OFFSET(devid, field, offset) DEFINE(OFF_##devid##_##field, offset)

int main(void) {
    /* Device IDs com estruturas conhecidas */
    DEVID(pci_device_id);
    DEVID_FIELD(pci_device_id, vendor);
    DEVID_FIELD(pci_device_id, device);
    DEVID_FIELD(pci_device_id, subvendor);
    DEVID_FIELD(pci_device_id, subdevice);
    DEVID_FIELD(pci_device_id, class);
    DEVID_FIELD(pci_device_id, class_mask);

    DEVID(usb_device_id);
    DEVID_FIELD(usb_device_id, match_flags);
    DEVID_FIELD(usb_device_id, idVendor);
    DEVID_FIELD(usb_device_id, idProduct);
    DEVID_FIELD(usb_device_id, bcdDevice_lo);
    DEVID_FIELD(usb_device_id, bcdDevice_hi);
    DEVID_FIELD(usb_device_id, bDeviceClass);
    DEVID_FIELD(usb_device_id, bDeviceSubClass);
    DEVID_FIELD(usb_device_id, bDeviceProtocol);
    DEVID_FIELD(usb_device_id, bInterfaceClass);
    DEVID_FIELD(usb_device_id, bInterfaceSubClass);
    DEVID_FIELD(usb_device_id, bInterfaceProtocol);
    DEVID_FIELD(usb_device_id, bInterfaceNumber);

    DEVID(hid_device_id);
    DEVID_FIELD(hid_device_id, bus);
    DEVID_FIELD(hid_device_id, group);
    DEVID_FIELD(hid_device_id, vendor);
    DEVID_FIELD(hid_device_id, product);

    DEVID(input_device_id);
    DEVID_FIELD(input_device_id, flags);
    DEVID_FIELD(input_device_id, bustype);
    DEVID_FIELD(input_device_id, vendor);
    DEVID_FIELD(input_device_id, product);
    DEVID_FIELD(input_device_id, version);
    DEVID_FIELD(input_device_id, evbit);
    DEVID_FIELD(input_device_id, keybit);
    DEVID_FIELD(input_device_id, relbit);
    DEVID_FIELD(input_device_id, absbit);
    DEVID_FIELD(input_device_id, mscbit);
    DEVID_FIELD(input_device_id, ledbit);
    DEVID_FIELD(input_device_id, sndbit);
    DEVID_FIELD(input_device_id, ffbit);
    DEVID_FIELD(input_device_id, swbit);

    DEVID(platform_device_id);
    DEVID_FIELD(platform_device_id, name);

    DEVID(i2c_device_id);
    DEVID_FIELD(i2c_device_id, name);

    DEVID(spi_device_id);
    DEVID_FIELD(spi_device_id, name);

    DEVID(dmi_system_id);
    DEVID_FIELD(dmi_system_id, matches);

    DEVID(mdio_device_id);
    DEVID_FIELD(mdio_device_id, phy_id);
    DEVID_FIELD(mdio_device_id, phy_id_mask);

    DEVID(zorro_device_id);
    DEVID_FIELD(zorro_device_id, id);

    DEVID(isapnp_device_id);
    DEVID_FIELD(isapnp_device_id, vendor);
    DEVID_FIELD(isapnp_device_id, function);

    DEVID(amba_id);
    DEVID_FIELD(amba_id, id);
    DEVID_FIELD(amba_id, mask);

    DEVID(x86_cpu_id);
    DEVID_FIELD(x86_cpu_id, feature);
    DEVID_FIELD(x86_cpu_id, family);
    DEVID_FIELD(x86_cpu_id, model);
    DEVID_FIELD(x86_cpu_id, vendor);

    DEVID(of_device_id);
    DEVID_FIELD(of_device_id, name);
    DEVID_FIELD(of_device_id, type);
    DEVID_FIELD(of_device_id, compatible);

    DEVID(virtio_device_id);
    DEVID_FIELD(virtio_device_id, device);
    DEVID_FIELD(virtio_device_id, vendor);

    DEVID(hv_vmbus_device_id);
    DEVID_FIELD(hv_vmbus_device_id, guid);

    /* Device IDs problemáticos - definir manualmente com offsets seguros */
    DEFINE(SIZE_ccw_device_id, 16);
    FAKE_OFFSET(ccw_device_id, match_flags, 0);
    FAKE_OFFSET(ccw_device_id, cu_type, 2);
    FAKE_OFFSET(ccw_device_id, cu_model, 4);
    FAKE_OFFSET(ccw_device_id, dev_type, 6);
    FAKE_OFFSET(ccw_device_id, dev_model, 8);

    DEFINE(SIZE_ap_device_id, 8);
    FAKE_OFFSET(ap_device_id, dev_type, 0);

    DEFINE(SIZE_css_device_id, 8);
    FAKE_OFFSET(css_device_id, type, 0);

    DEFINE(SIZE_pnp_device_id, 32);
    FAKE_OFFSET(pnp_device_id, id, 0);

    DEFINE(SIZE_pnp_card_device_id, 64);
    FAKE_OFFSET(pnp_card_device_id, devs, 0);

    /* Outros device IDs com definições fixas */
    DEFINE(SIZE_ssb_device_id, 16);
    FAKE_OFFSET(ssb_device_id, vendor, 0);
    FAKE_OFFSET(ssb_device_id, coreid, 2);
    FAKE_OFFSET(ssb_device_id, revision, 4);

    DEFINE(SIZE_bcma_device_id, 16);
    FAKE_OFFSET(bcma_device_id, manuf, 0);
    FAKE_OFFSET(bcma_device_id, id, 2);
    FAKE_OFFSET(bcma_device_id, rev, 4);
    FAKE_OFFSET(bcma_device_id, class, 6);

    DEFINE(SIZE_parisc_device_id, 16);
    FAKE_OFFSET(parisc_device_id, hw_type, 0);
    FAKE_OFFSET(parisc_device_id, hversion, 2);
    FAKE_OFFSET(parisc_device_id, hversion_rev, 4);
    FAKE_OFFSET(parisc_device_id, sversion, 6);

    DEFINE(SIZE_sdio_device_id, 12);
    FAKE_OFFSET(sdio_device_id, class, 0);
    FAKE_OFFSET(sdio_device_id, vendor, 2);
    FAKE_OFFSET(sdio_device_id, device, 4);

    DEFINE(SIZE_ieee1394_device_id, 20);
    FAKE_OFFSET(ieee1394_device_id, match_flags, 0);
    FAKE_OFFSET(ieee1394_device_id, vendor_id, 4);
    FAKE_OFFSET(ieee1394_device_id, model_id, 8);
    FAKE_OFFSET(ieee1394_device_id, specifier_id, 12);
    FAKE_OFFSET(ieee1394_device_id, version, 16);

    DEFINE(SIZE_serio_device_id, 8);
    FAKE_OFFSET(serio_device_id, type, 0);
    FAKE_OFFSET(serio_device_id, proto, 1);
    FAKE_OFFSET(serio_device_id, id, 2);
    FAKE_OFFSET(serio_device_id, extra, 3);

    DEFINE(SIZE_acpi_device_id, 16);
    FAKE_OFFSET(acpi_device_id, id, 0);

    DEFINE(SIZE_pcmcia_device_id, 32);
    FAKE_OFFSET(pcmcia_device_id, match_flags, 0);
    FAKE_OFFSET(pcmcia_device_id, manf_id, 4);
    FAKE_OFFSET(pcmcia_device_id, card_id, 6);
    FAKE_OFFSET(pcmcia_device_id, func_id, 8);
    FAKE_OFFSET(pcmcia_device_id, function, 9);
    FAKE_OFFSET(pcmcia_device_id, device_no, 10);
    FAKE_OFFSET(pcmcia_device_id, prod_id_hash, 12);

    DEFINE(SIZE_eisa_device_id, 16);
    FAKE_OFFSET(eisa_device_id, sig, 0);

    DEFINE(SIZE_vio_device_id, 64);
    FAKE_OFFSET(vio_device_id, type, 0);
    FAKE_OFFSET(vio_device_id, compat, 32);

    return 0;
}
DEVICETABLE_EOF

    # Aplicar patches
    local patches_applied=0
    echo "=== APLICANDO PATCHES ==="
    for p in $(echo "$source" | tr ' ' '\n' | grep '\.patch$' | sort -V); do
        if [ -f "$srcdir/$p" ]; then
            if patch -p1 -i "$srcdir/$p" >/dev/null 2>&1; then
                echo "✓ $p"
                patches_applied=$((patches_applied + 1))
            else
                echo "✗ $p (já aplicado ou conflito)"
            fi
        else
            echo "⚠ $p (não encontrado)"
        fi
    done
    echo "Patches aplicados: $patches_applied"

    # Config
    if [ -f "$srcdir/config-samsung-matisse3g.armv7" ]; then
        cp "$srcdir/config-samsung-matisse3g.armv7" .config
        echo "✓ Config copiada"
    fi

    # Build inicial do sistema
    make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" scripts_basic >/dev/null 2>&1 || true
    yes "" | make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" oldconfig >/dev/null 2>&1 || true
}

build() {
    cd "$builddir"

    echo "=== VERIFICAÇÕES FINAIS ==="

    # Verificar se __printf está definido
    if grep -q "__printf.*format" include/linux/compiler-gcc*.h 2>/dev/null; then
        echo "✓ __printf macro definido"
    else
        echo "✗ __printf macro ausente"
    fi

    # Verificar devicetable offsets
    if grep -q "OFF_ccw_device_id" scripts/mod/devicetable-offsets.c 2>/dev/null; then
        echo "✓ Devicetable offsets definidos"
    else
        echo "✗ Devicetable offsets ausentes"
    fi

    # Verificar tipos básicos
    if grep -q "__u32" scripts/mod/devicetable-offsets.c 2>/dev/null; then
        echo "✓ Tipos básicos definidos"
    else
        echo "✗ Tipos básicos ausentes"
    fi

    echo ""
    echo "=== INICIANDO BUILD ==="

    # Build com timeout e logging detalhado
    if ! timeout 3600 make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" \
         HOSTCC=gcc HOSTCFLAGS="$HOSTCFLAGS" KBUILD_CFLAGS="$KBUILD_CFLAGS" \
         EXTRA_CFLAGS="$EXTRA_CFLAGS" KBUILD_CPPFLAGS="$KBUILD_CPPFLAGS" \
         V=1 -j$(nproc) zImage 2>&1 | tee build.log; then

        echo ""
        echo "=== BUILD FALHOU - ANÁLISE ==="

        # Análise específica dos erros
        if grep -q "__printf.*expected declaration" build.log; then
            echo "ERRO: Problema com macro __printf ainda persiste"
            echo "Verificando definições..."
            grep -n "__printf" include/linux/compiler*.h 2>/dev/null || echo "Não encontrado"
        fi

        if grep -q "OFF_.*_undeclared" build.log; then
            echo "ERRO: Offsets de devicetable ainda ausentes"
            echo "Verificando devicetable-offsets.c..."
            head -20 scripts/mod/devicetable-offsets.c
        fi

        if grep -q "__u32.*unknown type" build.log; then
            echo "ERRO: Tipos básicos não definidos corretamente"
        fi

        # Mostrar contexto do erro
        echo ""
        echo "=== CONTEXTO DO ERRO ==="
        grep -B2 -A2 -E "(error|Error|fatal)" build.log | head -20

        exit 1
    fi

    # Verificar se zImage foi criado
    if [ -f arch/arm/boot/zImage ]; then
        local size=$(stat -c%s arch/arm/boot/zImage)
        echo "SUCCESS! zImage criado: $size bytes"
    else
        echo "ERRO: zImage não foi criado"
        exit 1
    fi

    # Build dos módulos (opcional)
    make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" modules >/dev/null 2>&1 || true
}

package() {
    cd "$builddir"

    # Instalar kernel
    install -Dm644 arch/arm/boot/zImage "$pkgdir/boot/vmlinuz-$_flavor"

    # Instalar módulos se existirem
    make DESTDIR="$pkgdir" INSTALL_MOD_PATH="$pkgdir" ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" modules_install 2>/dev/null || true

    # Instalar DTBs se existirem
    if [ -d arch/arm/boot/dts ]; then
        mkdir -p "$pkgdir/boot/dtbs-$_flavor"
        find arch/arm/boot/dts -name "*.dtb" -exec cp {} "$pkgdir/boot/dtbs-$_flavor/" \; 2>/dev/null || true
    fi

    # Link simbólico
    mkdir -p "$pkgdir/boot"
    ln -sf "vmlinuz-$_flavor" "$pkgdir/boot/vmlinuz" || true
}

sha512sums="
7fa4253037e154e2f245e12b4d7999887d6fcf99c9e7d30601ecf53a2fe5d47f1a423dd9483dac9eec86b7e5a9daf0b48e8ddde7311cd091a66630ff0656bd45  linux-samsung-matisse3g-pmos-matisse3g-fixes.tar.gz
4eff4dab705a03c3ce5082b00469b1d8728f6cda27a5e79786cc9bdb299f8421d016c74b0aa3e3da39e6849ac39d962b5a11aa7794ba18c5a376161447147c31  config-samsung-matisse3g.armv7
f3bbc54d1c3433310f701c0da130c165d8baab29d924ad90a7021c40818e767066c10b6c2467b97d92b43191a7d0e1bb389dc056463263c14347e9e4582ae0ca  01-fix-timex-header.patch
726321e16d16edad715abd4bc83e9f546902e11b5d2c5f5ab1b7076872ad0fceee85d2e512e8007a78c0a956b3454b239b9a844149a87094a342d91030972889  03-fix-defconfig.patch
7462871c23903b5b061117757adb82da2e80caeadf44f941686ca1bba8c67a337d5d1ffdf94350cdd964ecc7651adec6770cc0801e18e60872b72490e917fa02  04-fix-jffs2-format-warnings.patch
ce5dd92a66e208c873919aea7f571b72bd7811482b7f846d9bb62e22da5eb7671e941168fc413ee87e2e434d96799843f3a5690789c460651d7120d72dfaf3e3  05-fix-fundamental-headers.patch
9cdd95f4701f1f659fdeb9aa51529d71c5f0102f6422cfbc6ef1d37b5f6071515be816bf825c7d84ed4fa118c26dc1871aed5a7721e64fb73db8ed5803f65581  06-add-missing-byteorder-headers.patch
ea9fd7ed6e4ad9f51cf8f852cabe13fe6d725f77f04cb9aff584844156f6355ac55aafed6ae6cfc94cc032c15830057867a08ce1acf2e4985aed8bba4010b132  07-fix-compiler-headers.patch
c0567e7c8f8458663296a6bdddac021dd8417055f2f17fa96c13ce39cf6502fffa23897eecac9911fce515f4f7f716d0ff394334fe6a36036c67832c378e0f43  08-fix-asm-offsets-simple.patch
7486b8f2841205e9988719a7cff4508965bd6b5808c57ab0ac3f31cdcdf297234cd3b7ab703c142513bca699d024026577ebbe720e8c2187d821a68808e86cd5  09-fix-memory-and-const.patch
c100588d2c68d4ca7564cfc5dfabe55d0ffef60d6d4bf3561b551db851ce472951ef3521ea2cad5099c65137bc230a5f17aaff81f95486ab8a0ff602114e6a24  10-add-gcc15-conservative-flags.patch
7380d8e468c4183230871ebc38cc5ef853adb59683774e7a7ced7430ee12bf5091b003197aa5af4028ddfc731e1b921f27e5e2e357023bb0ac82918d73fc612a  11-fix-irq-timer-definitions-v2.patch
235a13b089f624f65cf3533c8480fad10bc76bb322a2cdae93ca68115e3eb52a58a97b3dd2ee89cceb79185451d3a8599562d6188c2d172479e2a43846c51bdf  12-fix-proc-v7-assembly.patch
6d881eb39c17e38b829c8568bcb98960ef570a709731c6b3327c5130c3181cdc555adbd6bb3915a8d6d377c9268e1cc790a78a3a10b682a20d05ea9425f27721  13-fix-bool-redefinitions.patch
bcaf48edc68de62aeae3c97c0419ae7e78ac3d65ced9d08cb1d397561bc546de9f632c1f398c7b04a4f8326ea01238f3204efdd1f96db860f32122a96c2736d1  14-fix-fs-build-errors.patch
b31c13237d0f45bc9649be5915d0d37a9d40d3063d53f49b874481cb517d1bb5038af5071470f43ce07b160dcc2df60a65344bc49f9131ccaddab0dc4d55cdce  15-ultimate-macro-redefinition-fix.patch
068a2b50a9125c8cc23897910edffa3b08fdab5e082679e90937b9f984da8fb3b99d9a415fac9314cfeba85e9729bc0405875627a3b01aa36dfbe2a7f8821de2  16-fix-ext4-strncpy-warnings.patch
fa48d727a40e0b305bf6c824c0416d9494281b9a5bf00b54074da1ac72002aa4fd25e556bdfee83afc50085d1e424cecf258e5098d25ca654a6777b91dc40be3  22-ultimate-all-offsets-final.patch
e0bf78d0247d8969cae6c9b18fafddb53dfdcf08155b7c9dfa327ed0ca369f74c7d7801b03595464dba28a93e87c7010c6dce812cc016f67a876a80ae6528c59  23-fix-arm-architecture-detection.patch
bc7c43f87eec73705a993ff971cf159933e762b0f658a124cdfd717ebe577a063b1d9eac71c51356244f0d579e2afbe75d14b66890d175932eb05d9dc502ccee  24-fix-devicetable-basic-types.patch
413fb977d4b3cdcc219be6381d9635c2a81da4884754f0c3c2fed9781a1e0ff56aa9715c9b14d16d102a5841a63cdd65febe8c8fa2e3aacde5c96797cd0904c0  25-fix-printf-macro.patch
ede2e6c6460a01477b4ed8e8e768c758f40459c6e07ed6fc3609fcadb2d51f23d71fd8b0930a7e1fb6aa03156c2e0431690b1af4fe5b86750ad2f15006c9a005  26-fix-string-header-inclusion.patch
dcd2ab1e0e7d5a6484f6e278328003d2e8fe51aed94bc431b239cd7d63af9189b28d642b794804dfd3d95c9448c366958f25da88d6d9e9ed0befcbc15f4e2c7b  27-fix-fundamental-types-comprehensive.patch
"
