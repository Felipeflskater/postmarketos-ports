# Maintainer: Felipe Prestes Aranalde <felipe.aranalde@gmail.com>
pkgname=linux-samsung-matisse3g
pkgver=3.4.113
pkgrel=124
pkgdesc="Kernel Linux para Samsung Galaxy Tab 4 10.1 (SM-T531)"
arch="armv7"
_flavor="samsung-matisse3g"
url="https://github.com/felipeflskater/android_kernel_samsung_msm8226"
license="GPL-2.0-only"
options="!strip !check !tracedeps pmb:cross-native"
makedepends="bash bc bison devicepkg-dev dtbtool elfutils-dev findutils flex gmp-dev installkernel linux-headers mpc1-dev mpfr-dev perl python3 sed xz"

_commit="pmos-matisse3g-fixes"

source="
	$pkgname-$_commit.tar.gz::https://github.com/Felipeflskater/android_kernel_samsung_msm8226/archive/refs/heads/$_commit.tar.gz
	config-samsung-matisse3g.armv7
	01-fix-timex-header.patch
	03-fix-defconfig.patch
	08-fix-asm-offsets-simple.patch
	10-add-gcc15-conservative-flags.patch
	11-fix-irq-timer-definitions-v2.patch
	12-fix-section-mismatch.patch
	13-disable-stack-protector.patch
	40-create-compiler-gcc14-header.patch
	55-fix-proc-pid-init-ino.patch
"
builddir="$srcdir/android_kernel_samsung_msm8226-$_commit"

prepare() {
    cd "$builddir"

    # Setup básico
    for comp in armv7-alpine-linux-musleabihf-gcc arm-linux-gnueabihf-gcc; do
        command -v "$comp" >/dev/null 2>&1 && export CROSS_COMPILE="${comp%-gcc}-" && break
    done

    unset LDFLAGS CPPFLAGS CFLAGS CXXFLAGS KCFLAGS AFLAGS
    export ARCH=arm HOSTCC=gcc
    export HOSTCFLAGS="-O1 -w -std=gnu89"
    export KBUILD_CFLAGS="-w -std=gnu89 -marm -mno-thumb-interwork -Wno-error -fno-stack-protector"
    export KBUILD_AFLAGS="-D__ASSEMBLY__ -marm -mno-thumb-interwork -fno-stack-protector"
    export EXTRA_CFLAGS="-w -marm -mno-thumb-interwork -fno-stack-protector"

    mkdir -p include/generated include/config arch/arm/include/generated/asm
    echo '#define UTS_RELEASE "3.4.113"' > include/generated/utsrelease.h
    cat > include/generated/autoconf.h << 'EOF'
#define CONFIG_ARM 1
#define CONFIG_CPU_V7 1
#define CONFIG_MSM_PM 1
EOF
    touch include/generated/asm-offsets.h include/generated/bounds.h

    # Aplicar patches básicos primeiro
    echo "Aplicando patches..."
    for p in 01-fix-timex-header.patch \
             03-fix-defconfig.patch \
             08-fix-asm-offsets-simple.patch \
             10-add-gcc15-conservative-flags.patch \
             11-fix-irq-timer-definitions-v2.patch \
             12-fix-section-mismatch.patch \
             13-disable-stack-protector.patch \
             40-create-compiler-gcc14-header.patch \
             55-fix-proc-pid-init-ino.patch; do
        if [ -f "$srcdir/$p" ]; then
            echo "  Aplicando $p..."
            patch -p1 -i "$srcdir/$p" || {
                echo "  ERRO ao aplicar $p"
                exit 1
            }
        fi
    done

    # Corrigir assembler.h com TODAS as macros necessárias
    echo "Reconstruindo assembler.h completo..."
    cat > arch/arm/include/asm/assembler.h << 'ASSEMBLER_COMPLETE_EOF'
#ifndef __ASM_ASSEMBLER_H__
#define __ASM_ASSEMBLER_H__

#ifndef __ASSEMBLY__
#error "Only include this from assembly code"
#endif

#include <asm/ptrace.h>
#include <asm/domain.h>

#ifndef __LINUX_ARM_ARCH__
#define __LINUX_ARM_ARCH__ 7
#endif

/*
 * Endian independent macros for shifting bytes within registers.
 */
#ifndef __ARMEB__
#define lspull          lsr
#define lspush          lsl
#define get_byte_0      lsl #0
#define get_byte_1      lsr #8
#define get_byte_2      lsr #16
#define get_byte_3      lsr #24
#define put_byte_0      lsl #0
#define put_byte_1      lsl #8
#define put_byte_2      lsl #16
#define put_byte_3      lsl #24
#else
#define lspull          lsl
#define lspush          lsr
#define get_byte_0      lsr #24
#define get_byte_1      lsr #16
#define get_byte_2      lsr #8
#define get_byte_3      lsl #0
#define put_byte_0      lsl #24
#define put_byte_1      lsl #16
#define put_byte_2      lsl #8
#define put_byte_3      lsl #0
#endif

/* Select code for any configuration running in ARM mode */
#ifdef CONFIG_THUMB2_KERNEL
	.macro arm, args:vararg
	.endm
	.macro thumb, args:vararg
	\args
	.endm
#else
	.macro arm, args:vararg
	\args
	.endm
	.macro thumb, args:vararg
	.endm
#endif

/*
 * SMP data memory barrier
 */
	.macro	smp_dmb mode
#ifdef CONFIG_SMP
	dmb	\mode
#endif
	.endm

#ifdef CONFIG_SMP
#define ALT_SMP(instr...)					\
9998:	instr
#define ALT_UP(instr...)					\
	.pushsection ".alt.smp.init", "a"			;\
	.long	9998b						;\
9997:	instr							;\
	.if . - 9997b != 4					;\
		.error "ALT_UP() content must assemble to exactly 4 bytes";\
	.endif							;\
	.popsection
#define ALT_UP_B(label)					\
	.equ	up_b_offset, label - 9998b			;\
	.pushsection ".alt.smp.init", "a"			;\
	.long	9998b						;\
	W(b)	. + up_b_offset					;\
	.popsection
#else
#define ALT_SMP(instr...)
#define ALT_UP(instr...) instr
#define ALT_UP_B(label) b label
#endif

	.macro	alt_smp, instr:vararg
	ALT_SMP(\instr)
	.endm

	.macro	alt_up, instr:vararg
	ALT_UP(\instr)
	.endm

	.macro	alt_up_b, label:req
	ALT_UP_B(\label)
	.endm

/*
 * Instruction barrier
 */
	.macro	instr_sync
#if __LINUX_ARM_ARCH__ >= 7
	isb
#elif __LINUX_ARM_ARCH__ == 6
	mcr	p15, 0, r0, c7, c5, 4
#endif
	.endm

/*
 * Save the current IRQ state and disable IRQs.  Note that this macro
 * assumes FIQs are enabled, and that the processor is in SVC mode.
 */
	.macro	save_and_disable_irqs, oldcpsr
	mrs	\oldcpsr, cpsr
	cpsid	i
	.endm

	.macro	save_and_disable_irqs_notrace, oldcpsr
	mrs	\oldcpsr, cpsr
	cpsid	i
	.endm

/*
 * Restore interrupt state previously stored in a register.  We don't
 * guarantee that this will preserve the flags.
 */
	.macro	restore_irqs_notrace, oldcpsr
	msr	cpsr_c, \oldcpsr
	.endm

	.macro restore_irqs, oldcpsr
	msr	cpsr_c, \oldcpsr
	.endm

	.macro disable_irq_notrace
	cpsid	i
	.endm

	.macro enable_irq_notrace
	cpsie	i
	.endm

	.macro disable_irq
	cpsid	i
	.endm

	.macro enable_irq
	cpsie	i
	.endm

	.macro save_and_disable_irqs_notrace, oldcpsr
	mrs	\oldcpsr, cpsr
	cpsid	i
	.endm

/*
 * BSYM - convert a symbol name to a byte address in the correct
 * instruction set (ARM or Thumb)
 */
#ifdef CONFIG_THUMB2_KERNEL
	.macro	BSYM, sym
	\sym + 1
	.endm
#else
	.macro	BSYM, sym
	\sym
	.endm
#endif

/*
 * Size of kernel page table entries
 */
#define PTE_HWTABLE_OFF		(PTE_HWTABLE_PTRS * sizeof(pte_t))
#define PTE_HWTABLE_SIZE	(PTRS_PER_PTE * sizeof(u32))

/*
 * These macros are used to allow symbolic substitution
 * for ARM instructions.
 */
	.irp	c,,eq,ne,cs,cc,mi,pl,vs,vc,hi,ls,ge,lt,gt,le,hs,lo
	.macro	ret\c, reg
#if __LINUX_ARM_ARCH__ < 6
	mov\c	pc, \reg
#else
	.ifeqs	"\reg", "lr"
	bx\c	\reg
	.else
	mov\c	pc, \reg
	.endif
#endif
	.endm
	.endr

	.macro	ret.w, reg
	ret	\reg
	.endm

/*
 * dsb - Data Synchronization Barrier
 */
	.macro	dsb, args:vararg
#if __LINUX_ARM_ARCH__ >= 7
	dsb	\args
#elif __LINUX_ARM_ARCH__ == 6
	mcr	p15, 0, r0, c7, c10, 4
#endif
	.endm

/*
 * User space access macros
 */
	.macro	usraccoff, instr, reg, ptr, inc, off, cond, abort, t=TUSER()
9999:
	.if	\inc == 1
	\instr\cond\()b\t \reg, [\ptr, #\off]
	.elseif	\inc == 4
	\instr\cond\t \reg, [\ptr, #\off]
	.else
	.error	"Unsupported inc macro argument"
	.endif

	.pushsection __ex_table,"a"
	.align	3
	.long	9999b, \abort
	.popsection
	.endm

	.macro	usracc, instr, reg, ptr, inc, cond, rept, abort
	.rept	\rept
	usraccoff \instr, \reg, \ptr, \inc, 0, \cond, \abort
	.if	\rept > 1
	add\cond \ptr, #\inc
	add\cond \reg, #\inc
	.endif
	.endr
	.endm

	.macro	user, args:vararg
	usracc	\args
	.endm

	.macro strusr, reg, ptr, inc, cond=al, rept=1, abort=9001f
	usracc	str, \reg, \ptr, \inc, \cond, \rept, \abort
	.endm

	.macro ldrusr, reg, ptr, inc, cond=al, rept=1, abort=9001f
	usracc	ldr, \reg, \ptr, \inc, \cond, \rept, \abort
	.endm

/* Utility macro for declaring string literals */
	.macro	string name:req, string
	.type	\name , #object
\name:
	.asciz	"\string"
	.size	\name, . - \name
	.endm

	.macro check_uaccess, addr:req, size:req, limit:req, tmp:req, bad:req
	adds	\tmp, \addr, #\size - 1
	sbcccs	\tmp, \tmp, \limit
	bcs	\bad
	.endm

	.irp	c,,eq,ne,cs,cc,mi,pl,vs,vc,hi,ls,ge,lt,gt,le,hs,lo
	.macro	loadsp, rb, tmp=ip
	ldr\c	\tmp, [\rb], #4
	.endm
	.endr

	.macro	writeb, ch, rb
	strb	\ch, [\rb], #1
	.endm

	.macro	store_user_sp_lr, base, tmp, offset = 0
	add	\tmp, \base, #\offset + 52
	stmia	\tmp, {sp, lr}^
	.endm

/*
 * Wide branch instruction macros
 */
	.irp	c,,eq,ne,cs,cc,mi,pl,vs,vc,hi,ls,ge,lt,gt,le,hs,lo
	.macro	b\c, target
#if __LINUX_ARM_ARCH__ >= 7
	b\c	\target
#else
	b\c	\target
#endif
	.endm
	.endr

	.macro	W, instr:vararg
	\instr
	.endm

	.macro	badr, reg, sym
	adr	\reg, \sym
	.endm

	.macro	enable_irq
	cpsie	i
	.endm

	.macro	disable_irq
	cpsid	i
	.endm

	.macro	enable_fiq
	cpsie	f
	.endm

	.macro	disable_fiq
	cpsid	f
	.endm

#define USER(x...)				\
9999:	x;					\
	.pushsection __ex_table,"a";		\
	.align	3;				\
	.long	9999b,9001f;			\
	.popsection

#define TUSER(x...)

#ifndef CONFIG_SMP
#define ALT_SMP(instr...)
#define ALT_UP(instr...) instr
#define ALT_UP_B(label) b label
#endif

	.macro	setmode, mode, reg
	mov	\reg, #\mode
	msr	cpsr_c, \reg
	.endm

	.macro	usr_ret, reg
	bx	\reg
	.endm

#endif /* __ASM_ASSEMBLER_H__ */
ASSEMBLER_COMPLETE_EOF

    echo "  ✓ assembler.h completo reconstruído"

    echo "Aplicando correções manuais..."

    # Definir __LINUX_ARM_ARCH__ em outros headers ARM necessários
    echo "Definindo __LINUX_ARM_ARCH__ em headers ARM..."
    for f in arch/arm/include/asm/spinlock.h \
             arch/arm/include/asm/div64.h \
             arch/arm/include/asm/atomic.h \
             arch/arm/include/asm/cmpxchg.h; do
        if [ -f "$f" ] && ! grep -q "^#define __LINUX_ARM_ARCH__" "$f"; then
            sed -i '1i#ifndef __LINUX_ARM_ARCH__\n#define __LINUX_ARM_ARCH__ 7\n#endif' "$f"
            echo "  ✓ $f"
        fi
    done

    # BUILD_BUG_ON
    sed -i 's/BUILD_BUG_ON(!__builtin_constant_p(offset));/\/\*BUILD_BUG_ON\*\//' include/linux/rcupdate.h 2>/dev/null

    # irqs.h
    sed -i '136{/^#endif$/d;}' arch/arm/mach-msm/include/mach/irqs.h 2>/dev/null

    # fiq_glue.S
    if [ -f arch/arm/mach-msm/fiq_glue.S ]; then
        if ! grep -q "#include <asm/ptrace.h>" arch/arm/mach-msm/fiq_glue.S; then
            sed -i '1i#include <linux/linkage.h>\n#include <asm/ptrace.h>\n#include <asm/assembler.h>' arch/arm/mach-msm/fiq_glue.S
            echo "  ✓ fiq_glue.S"
        fi
    fi

    # board-8226.c
    if [ -f arch/arm/mach-msm/board-8226.c ]; then
        echo "Corrigindo board-8226.c (stub)..."
        sed -i '/^static struct of_dev_auxdata msm_hsic_host_adata/,/^};/c\
static void *msm_hsic_host_adata = NULL;' arch/arm/mach-msm/board-8226.c

        sed -i '/^static struct of_dev_auxdata msm8226_auxdata_lookup/,/^};/c\
static void *msm8226_auxdata_lookup = NULL;' arch/arm/mach-msm/board-8226.c
    fi

    # smd_init_plat.c
    cat > arch/arm/mach-msm/smd_init_plat.c << 'EOF'
#include <linux/module.h>
#include <linux/init.h>
int __init smd_core_init(void) { return 0; }
static int __init msm_smd_driver_init(void) { return smd_core_init(); }
module_init(msm_smd_driver_init);
MODULE_LICENSE("GPL v2");
EOF

    # head.S
    for f in arch/arm/kernel/head.S arch/arm/kernel/head-common.S; do
        [ -f "$f" ] && sed -i '1i\.arm\n.syntax unified' "$f"
    done

    # Makefiles
    cat >> arch/arm/vfp/Makefile << 'EOF'

CFLAGS_vfpmodule.o += -marm
CFLAGS_vfpsingle.o += -marm
CFLAGS_vfpdouble.o += -marm
EOF

    cat >> arch/arm/kernel/Makefile << 'EOF'

CFLAGS_ptrace.o += -marm
CFLAGS_process.o += -marm
EOF

    cat >> arch/arm/mm/Makefile << 'EOF'

CFLAGS_fault.o += -marm
CFLAGS_init.o += -marm
EOF

    # module_param bool
    find . -name "*.c" -type f -exec sed -i \
        -e 's/module_param[[:space:]]*([[:space:]]*\([^,]*\)[[:space:]]*,[[:space:]]*bool[[:space:]]*,/module_param(\1, int,/g' \
        -e 's/module_param[[:space:]]*([[:space:]]*\([^,]*\)[[:space:]]*,[[:space:]]*_Bool[[:space:]]*,/module_param(\1, int,/g' \
        {} \; 2>/dev/null

    # Config
    cp "$srcdir/config-samsung-matisse3g.armv7" .config
    sed -i 's/# CONFIG_SMP is not set/CONFIG_SMP=y/' .config
    sed -i 's/CONFIG_NR_CPUS=1/CONFIG_NR_CPUS=4/' .config

    cat >> .config << 'EOF'
CONFIG_SMP=y
CONFIG_NR_CPUS=4
CONFIG_ARM_UNWIND=y
CONFIG_MSM_PM=y
CONFIG_DEBUG_SECTION_MISMATCH=n
CONFIG_NO_ERROR_ON_MISMATCH=y
CONFIG_HAVE_SMP=y
CONFIG_SMP_ON_UP=y
CONFIG_ARM_CPU_TOPOLOGY=y
CONFIG_SCHED_MC=y
EOF

    make scripts_basic >/dev/null 2>&1 || true
    yes "" | make oldconfig >/dev/null 2>&1 || true

    echo "Preparação concluída com sucesso!"
}

build() {
    cd "$builddir"
    timeout 2400 make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" \
        HOSTCFLAGS="$HOSTCFLAGS" KBUILD_CFLAGS="$KBUILD_CFLAGS" \
        KBUILD_AFLAGS="$KBUILD_AFLAGS" EXTRA_CFLAGS="$EXTRA_CFLAGS" \
        CONFIG_NO_ERROR_ON_MISMATCH=y KCFLAGS="-fno-stack-protector" \
        -j$(nproc) zImage || exit 1
    [ -f arch/arm/boot/zImage ] || exit 1
    make modules 2>/dev/null || true
}

package() {
    cd "$builddir"
    install -Dm644 arch/arm/boot/zImage "$pkgdir/boot/vmlinuz-$_flavor"
    make DESTDIR="$pkgdir" modules_install 2>/dev/null || true
    [ -d arch/arm/boot/dts ] && {
        mkdir -p "$pkgdir/boot/dtbs-$_flavor"
        find arch/arm/boot/dts -name "*.dtb" -exec cp {} "$pkgdir/boot/dtbs-$_flavor/" \;
    }
}

sha512sums="
7fa4253037e154e2f245e12b4d7999887d6fcf99c9e7d30601ecf53a2fe5d47f1a423dd9483dac9eec86b7e5a9daf0b48e8ddde7311cd091a66630ff0656bd45  linux-samsung-matisse3g-pmos-matisse3g-fixes.tar.gz
d8a95e9527bab186d5e0d40fcbef90c761bb2e8ca17a7441101c560ba2d3dab91b978a45220c6aa651fb502c7618f401bc2a783afe2bf1210a8e5ddd9e64f5a0  config-samsung-matisse3g.armv7
f3bbc54d1c3433310f701c0da130c165d8baab29d924ad90a7021c40818e767066c10b6c2467b97d92b43191a7d0e1bb389dc056463263c14347e9e4582ae0ca  01-fix-timex-header.patch
726321e16d16edad715abd4bc83e9f546902e11b5d2c5f5ab1b7076872ad0fceee85d2e512e8007a78c0a956b3454b239b9a844149a87094a342d91030972889  03-fix-defconfig.patch
c0567e7c8f8458663296a6bdddac021dd8417055f2f17fa96c13ce39cf6502fffa23897eecac9911fce515f4f7f716d0ff394334fe6a36036c67832c378e0f43  08-fix-asm-offsets-simple.patch
c100588d2c68d4ca7564cfc5dfabe55d0ffef60d6d4bf3561b551db851ce472951ef3521ea2cad5099c65137bc230a5f17aaff81f95486ab8a0ff602114e6a24  10-add-gcc15-conservative-flags.patch
7380d8e468c4183230871ebc38cc5ef853adb59683774e7a7ced7430ee12bf5091b003197aa5af4028ddfc731e1b921f27e5e2e357023bb0ac82918d73fc612a  11-fix-irq-timer-definitions-v2.patch
3df086eb955c08fa770b43a16008a4eee7753ff9f1a47780a5528f3fda96f1cfb8f705c6931c83cb2ac2b9b6d20737998f99d13ae4c8e88f958d762237c2dc47  12-fix-section-mismatch.patch
b738038c3aa96ddd210277626ccba22a1047d74b5a958f222f0983ba9771dab2210b2c39dc348398dce213d079e63c554379ddeacf071ad84d88a283c383c834  13-disable-stack-protector.patch
9609c8c3fb4829b595d00738a4f8ee1daa58cbf5ae3cc59eb7ecc89f04705e13bfbb2116ae4c8ca3e4ecff733c9a8bd982bca06a8e1dbad336be8e71108df65c  40-create-compiler-gcc14-header.patch
1e4a630a8d83663304568c1fe676a952212131e2d9b0b7f09c5008c25beea8b24b0d2d9e451707cfa66f1055d96b669f4f6d854fafada08d9e14ca08d4199f40  55-fix-proc-pid-init-ino.patch
"
