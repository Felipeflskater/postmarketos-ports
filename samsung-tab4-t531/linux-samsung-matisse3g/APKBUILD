# Maintainer: Felipe Prestes Aranalde <felipe.aranalde@gmail.com>
pkgname=linux-samsung-matisse3g
pkgver=3.4.113
pkgrel=22
pkgdesc="Kernel Linux para Samsung Galaxy Tab 4 10.1 (SM-T531) - Otimizado para PostmarketOS"
arch="armv7"
_flavor="samsung-matisse3g"
url="https://github.com/felipeflskater/android_kernel_samsung_msm8226"
license="GPL-2.0-only"
options="!strip !check !tracedeps pmb:cross-native"
makedepends="
	bash bc bison devicepkg-dev dtbtool elfutils-dev findutils flex
	gmp-dev installkernel linux-headers mpc1-dev mpfr-dev
	perl python3 sed xz gcc-arm-none-eabi
"

_commit="pmos-matisse3g-fixes"

source="
	$pkgname-$_commit.tar.gz::https://github.com/Felipeflskater/android_kernel_samsung_msm8226/archive/refs/heads/$_commit.tar.gz
	config-samsung-matisse3g.armv7
	01-fix-timex-header.patch
	03-fix-defconfig.patch
	04-fix-jffs2-format-warnings.patch
"
builddir="$srcdir/android_kernel_samsung_msm8226-$_commit"

_log() {
    printf "\n[*] %s\n" "$1"
}

_die() {
    _log "ERRO: $1"
    exit 1
}

_detect_cross_compiler() {
    local compilers="arm-none-eabi-gcc armv7-alpine-linux-musleabihf-gcc arm-linux-gnueabihf-gcc"

    for compiler in $compilers; do
        if command -v "$compiler" >/dev/null 2>&1; then
            export CROSS_COMPILE="${compiler%-gcc}-"
            _log "Usando $compiler"
            return 0
        fi
    done

    _die "Nenhum compilador cruzado ARM encontrado!"
}

_setup_gcc15_environment() {
    _log "Configurando ambiente para GCC 15+ com ARM v7..."

    # Limpar flags conflitantes
    unset LDFLAGS CPPFLAGS CFLAGS CXXFLAGS

    export ARCH=arm
    export SUBARCH=arm

    # Evitar redefinições
    unset __LINUX_ARM_ARCH__

    # CRÍTICO: Forçar arquitetura ARM v7 para Cortex-A7 (MSM8226)
    export ARM_ARCH="armv7-a"
    export CPU_TYPE="cortex-a7"

    # Host flags mais conservadores
    export HOSTCC="gcc"
    export HOSTCXX="g++"
    export HOSTCFLAGS="-fgnu89-inline -std=gnu89 -O2 -static -w"
    export HOSTCXXFLAGS="-fgnu89-inline -O2 -static -w"
    export HOSTLDFLAGS="-static"

    # Kernel flags com arquitetura ARM v7 específica
    local base_flags="-std=gnu89 -fno-stack-protector -fno-strict-aliasing -fno-common"
    local warning_flags="-w -Wno-error"
    local compat_flags="-fgnu89-inline -fno-strict-overflow -fconserve-stack"
    local gcc15_flags="-fno-PIE -fno-pic -no-pie"
    local arm_flags="-march=armv7-a -mcpu=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=softfp"
    arm_flags="$arm_flags -marm -mno-thumb-interwork"

    export KCFLAGS="$base_flags $warning_flags $compat_flags $gcc15_flags $arm_flags"

    # Assembly flags com suporte ARM v7
    export AFLAGS="-Wa,-march=armv7-a -Wa,-mcpu=cortex-a7 -Wa,--noexecstack"
    export KBUILD_AFLAGS="$AFLAGS"
    export KBUILD_CFLAGS="$KCFLAGS"

    # Forçar versões fixas
    export KERNELRELEASE="3.4.113"
    export UTS_RELEASE="3.4.113"

    # Flags adicionais para evitar conflitos
    export EXTRA_CFLAGS="-Wno-macro-redefined -D__LINUX_ARM_ARCH__=7"
    export KBUILD_CPPFLAGS="-D__LINUX_ARM_ARCH__=7"

    _log "Ambiente ARM v7 configurado para Cortex-A7"
}

# Correção para os problemas fundamentais identificados pelo cpp -E
_fix_fundamental_headers() {
    _log "Corrigindo headers fundamentais identificados pelo cpp..."

    # 1. CRÍTICO: Corrigir include/linux/types.h - remover warning do userspace
    if [ -f include/linux/types.h ]; then
        _log "Corrigindo include/linux/types.h..."
        [ ! -f include/linux/types.h.orig ] && cp include/linux/types.h include/linux/types.h.orig

        # Remover o warning problemático da linha 13
        sed -i '/#warning.*kernel headers from user space/d' include/linux/types.h

        # Garantir que __KERNEL__ está definido no contexto correto
        if ! grep -q "#ifdef __KERNEL__" include/linux/types.h | head -5; then
            sed -i '1i\
#ifndef __KERNEL__\
#define __KERNEL__\
#endif' include/linux/types.h
        fi
    fi

    # 2. CRÍTICO: Corrigir BITS_PER_LONG - problema no include/asm-generic/bitops/fls64.h
    _log "Definindo BITS_PER_LONG para ARM..."

    # Criar um header que define BITS_PER_LONG antes de qualquer include
    cat > include/linux/bits_per_long_fix.h << 'EOF'
#ifndef _LINUX_BITS_PER_LONG_FIX_H
#define _LINUX_BITS_PER_LONG_FIX_H

/* PostmarketOS: Force BITS_PER_LONG definition for ARM */
#ifndef BITS_PER_LONG
#ifdef CONFIG_64BIT
#define BITS_PER_LONG 64
#else
#define BITS_PER_LONG 32
#endif
#endif

#ifndef __BITS_PER_LONG
#define __BITS_PER_LONG BITS_PER_LONG
#endif

/* Also define BITS_PER_LONG_LONG */
#ifndef BITS_PER_LONG_LONG
#define BITS_PER_LONG_LONG 64
#endif

#endif /* _LINUX_BITS_PER_LONG_FIX_H */
EOF

    # Incluir este fix no início de arquivos problemáticos
    for file in include/asm-generic/bitops/fls64.h include/asm-generic/bitops/sched.h; do
        if [ -f "$file" ]; then
            _log "Corrigindo $file..."
            [ ! -f "$file.orig" ] && cp "$file" "$file.orig"
            sed -i '1i\
#include <linux/bits_per_long_fix.h>' "$file"
        fi
    done

    # 3. CRÍTICO: Criar linux/byteorder.h que está faltando
    _log "Criando linux/byteorder.h faltante..."
    cat > include/linux/byteorder.h << 'EOF'
#ifndef _LINUX_BYTEORDER_H
#define _LINUX_BYTEORDER_H

/* PostmarketOS: Minimal byteorder.h */

#include <linux/types.h>

/* Include the architecture specific byte order definition */
#ifdef __ARMEB__
#include <linux/byteorder/big_endian.h>
#else
#include <linux/byteorder/little_endian.h>
#endif

#endif /* _LINUX_BYTEORDER_H */
EOF

    # 4. CRÍTICO: Corrigir arch/arm/include/asm/swab.h
    if [ -f arch/arm/include/asm/swab.h ]; then
        _log "Corrigindo arch/arm/include/asm/swab.h..."
        [ ! -f arch/arm/include/asm/swab.h.orig ] && cp arch/arm/include/asm/swab.h arch/arm/include/asm/swab.h.orig

        # Substituir o include problemático
        sed -i 's/#include <linux\/byteorder.h>/#include <linux\/byteorder\/little_endian.h>/' arch/arm/include/asm/swab.h
    fi

    # 5. Criar stubs para byteorder se necessário
    mkdir -p include/linux/byteorder
    if [ ! -f include/linux/byteorder/little_endian.h ]; then
        _log "Criando include/linux/byteorder/little_endian.h..."
        cat > include/linux/byteorder/little_endian.h << 'EOF'
#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H

#include <linux/types.h>
#include <linux/swab.h>

#define __LITTLE_ENDIAN 1234
#define __BIG_ENDIAN 4321
#define __PDP_ENDIAN 3412
#define __BYTE_ORDER __LITTLE_ENDIAN

/* Little endian definitions */
#define __constant_htonl(x) ((__force __be32)___constant_swab32((x)))
#define __constant_ntohl(x) ___constant_swab32((__force __be32)(x))
#define __constant_htons(x) ((__force __be16)___constant_swab16((x)))
#define __constant_ntohs(x) ___constant_swab16((__force __be16)(x))
#define __constant_cpu_to_le64(x) ((__force __le64)(__u64)(x))
#define __constant_le64_to_cpu(x) ((__force __u64)(__le64)(x))
#define __constant_cpu_to_le32(x) ((__force __le32)(__u32)(x))
#define __constant_le32_to_cpu(x) ((__force __u32)(__le32)(x))
#define __constant_cpu_to_le16(x) ((__force __le16)(__u16)(x))
#define __constant_le16_to_cpu(x) ((__force __u16)(__le16)(x))
#define __constant_cpu_to_be64(x) ((__force __be64)___constant_swab64((x)))
#define __constant_be64_to_cpu(x) ___constant_swab64((__force __be64)(x))
#define __constant_cpu_to_be32(x) ((__force __be32)___constant_swab32((x)))
#define __constant_be32_to_cpu(x) ___constant_swab32((__force __be32)(x))
#define __constant_cpu_to_be16(x) ((__force __be16)___constant_swab16((x)))
#define __constant_be16_to_cpu(x) ___constant_swab16((__force __be16)(x))

#define __cpu_to_le64(x) ((__force __le64)(__u64)(x))
#define __le64_to_cpu(x) ((__force __u64)(__le64)(x))
#define __cpu_to_le32(x) ((__force __le32)(__u32)(x))
#define __le32_to_cpu(x) ((__force __u32)(__le32)(x))
#define __cpu_to_le16(x) ((__force __le16)(__u16)(x))
#define __le16_to_cpu(x) ((__force __u16)(__le16)(x))
#define __cpu_to_be64(x) ((__force __be64)__swab64((x)))
#define __be64_to_cpu(x) __swab64((__force __u64)(__be64)(x))
#define __cpu_to_be32(x) ((__force __be32)__swab32((x)))
#define __be32_to_cpu(x) __swab32((__force __u32)(__be32)(x))
#define __cpu_to_be16(x) ((__force __be16)__swab16((x)))
#define __be16_to_cpu(x) __swab16((__force __u16)(__be16)(x))

static inline __le64 __cpu_to_le64p(const __u64 *p) { return (__force __le64)*p; }
static inline __u64 __le64_to_cpup(const __le64 *p) { return (__force __u64)*p; }
static inline __le32 __cpu_to_le32p(const __u32 *p) { return (__force __le32)*p; }
static inline __u32 __le32_to_cpup(const __le32 *p) { return (__force __u32)*p; }
static inline __le16 __cpu_to_le16p(const __u16 *p) { return (__force __le16)*p; }
static inline __u16 __le16_to_cpup(const __le16 *p) { return (__force __u16)*p; }
static inline __be64 __cpu_to_be64p(const __u64 *p) { return (__force __be64)__swab64p(p); }
static inline __u64 __be64_to_cpup(const __be64 *p) { return __swab64p((__u64 *)p); }
static inline __be32 __cpu_to_be32p(const __u32 *p) { return (__force __be32)__swab32p(p); }
static inline __u32 __be32_to_cpup(const __be32 *p) { return __swab32p((__u32 *)p); }
static inline __be16 __cpu_to_be16p(const __u16 *p) { return (__force __be16)__swab16p(p); }
static inline __u16 __be16_to_cpup(const __be16 *p) { return __swab16p((__u16 *)p); }

#define __cpu_to_le64s(x) do { (void)(x); } while (0)
#define __le64_to_cpus(x) do { (void)(x); } while (0)
#define __cpu_to_le32s(x) do { (void)(x); } while (0)
#define __le32_to_cpus(x) do { (void)(x); } while (0)
#define __cpu_to_le16s(x) do { (void)(x); } while (0)
#define __le16_to_cpus(x) do { (void)(x); } while (0)
#define __cpu_to_be64s(x) __swab64s((x))
#define __be64_to_cpus(x) __swab64s((x))
#define __cpu_to_be32s(x) __swab32s((x))
#define __be32_to_cpus(x) __swab32s((x))
#define __cpu_to_be16s(x) __swab16s((x))
#define __be16_to_cpus(x) __swab16s((x))

#include <linux/byteorder/generic.h>

#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
EOF
    fi

    # 6. Criar linux/swab.h se necessário
    if [ ! -f include/linux/swab.h ]; then
        _log "Criando include/linux/swab.h..."
        cat > include/linux/swab.h << 'EOF'
#ifndef _LINUX_SWAB_H
#define _LINUX_SWAB_H

#include <linux/types.h>
#include <linux/compiler.h>
#include <asm/swab.h>

/* PostmarketOS: Minimal swab.h for byte swapping */

#define ___swab16(x) \
({ \
    __u16 __x = (x); \
    ((__u16)( \
        (((__u16)(__x) & (__u16)0x00ffU) << 8) | \
        (((__u16)(__x) & (__u16)0xff00U) >> 8) )); \
})

#define ___swab32(x) \
({ \
    __u32 __x = (x); \
    ((__u32)( \
        (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | \
        (((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) | \
        (((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) | \
        (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); \
})

#define ___swab64(x) \
({ \
    __u64 __x = (x); \
    ((__u64)( \
        (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
        (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
        (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
        (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
        (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
        (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
        (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
        (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); \
})

#define ___constant_swab16(x) ((__u16)( \
	(((__u16)(x) & (__u16)0x00ffU) << 8) | \
	(((__u16)(x) & (__u16)0xff00U) >> 8)))

#define ___constant_swab32(x) ((__u32)( \
	(((__u32)(x) & (__u32)0x000000ffUL) << 24) | \
	(((__u32)(x) & (__u32)0x0000ff00UL) <<  8) | \
	(((__u32)(x) & (__u32)0x00ff0000UL) >>  8) | \
	(((__u32)(x) & (__u32)0xff000000UL) >> 24)))

#define ___constant_swab64(x) ((__u64)( \
	(((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | \
	(((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) | \
	(((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | \
	(((__u64)(x) & (__u64)0x00000000ff000000ULL) <<  8) | \
	(((__u64)(x) & (__u64)0x000000ff00000000ULL) >>  8) | \
	(((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
	(((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) | \
	(((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56)))

static inline __u16 __swab16p(const __u16 *p) { return ___swab16(*p); }
static inline __u32 __swab32p(const __u32 *p) { return ___swab32(*p); }
static inline __u64 __swab64p(const __u64 *p) { return ___swab64(*p); }
static inline void __swab16s(__u16 *p) { *p = __swab16p(p); }
static inline void __swab32s(__u32 *p) { *p = __swab32p(p); }
static inline void __swab64s(__u64 *p) { *p = __swab64p(p); }

#define __swab16(x) ___swab16(x)
#define __swab32(x) ___swab32(x)
#define __swab64(x) ___swab64(x)

#endif /* _LINUX_SWAB_H */
EOF
    fi

    # 7. Criar byteorder/generic.h
    if [ ! -f include/linux/byteorder/generic.h ]; then
        _log "Criando include/linux/byteorder/generic.h..."
        cat > include/linux/byteorder/generic.h << 'EOF'
#ifndef _LINUX_BYTEORDER_GENERIC_H
#define _LINUX_BYTEORDER_GENERIC_H

/* PostmarketOS: Generic byte order conversions */

#define cpu_to_le64 __cpu_to_le64
#define le64_to_cpu __le64_to_cpu
#define cpu_to_le32 __cpu_to_le32
#define le32_to_cpu __le32_to_cpu
#define cpu_to_le16 __cpu_to_le16
#define le16_to_cpu __le16_to_cpu
#define cpu_to_be64 __cpu_to_be64
#define be64_to_cpu __be64_to_cpu
#define cpu_to_be32 __cpu_to_be32
#define be32_to_cpu __be32_to_cpu
#define cpu_to_be16 __cpu_to_be16
#define be16_to_cpu __be16_to_cpu

#define cpu_to_le64p __cpu_to_le64p
#define le64_to_cpup __le64_to_cpup
#define cpu_to_le32p __cpu_to_le32p
#define le32_to_cpup __le32_to_cpup
#define cpu_to_le16p __cpu_to_le16p
#define le16_to_cpup __le16_to_cpup
#define cpu_to_be64p __cpu_to_be64p
#define be64_to_cpup __be64_to_cpup
#define cpu_to_be32p __cpu_to_be32p
#define be32_to_cpup __be32_to_cpup
#define cpu_to_be16p __cpu_to_be16p
#define be16_to_cpup __be16_to_cpup

#define cpu_to_le64s __cpu_to_le64s
#define le64_to_cpus __le64_to_cpus
#define cpu_to_le32s __cpu_to_le32s
#define le32_to_cpus __le32_to_cpus
#define cpu_to_le16s __cpu_to_le16s
#define le16_to_cpus __le16_to_cpus
#define cpu_to_be64s __cpu_to_be64s
#define be64_to_cpus __be64_to_cpus
#define cpu_to_be32s __cpu_to_be32s
#define be32_to_cpus __be32_to_cpus
#define cpu_to_be16s __cpu_to_be16s
#define be16_to_cpus __be16_to_cpus

#define htonl(x) __cpu_to_be32(x)
#define ntohl(x) __be32_to_cpu(x)
#define htons(x) __cpu_to_be16(x)
#define ntohs(x) __be16_to_cpu(x)

#endif /* _LINUX_BYTEORDER_GENERIC_H */
EOF
    fi

    _log "Headers fundamentais corrigidos"
}

# Função para aplicar correções via código
_apply_code_fixes() {
    _log "Aplicando correções via código..."

    # CORREÇÃO 1: Remoção completa do compiler.h problemático
    if [ -f include/linux/compiler.h ]; then
        _log "Removendo compiler.h problemático e criando versão minimalista..."
        [ ! -f include/linux/compiler.h.orig ] && cp include/linux/compiler.h include/linux/compiler.h.orig

        cat > include/linux/compiler.h << 'EOF'
#ifndef __LINUX_COMPILER_H
#define __LINUX_COMPILER_H

#ifndef __ASSEMBLY__

#ifdef __CHECKER__
# define __user		__attribute__((noderef, address_space(1)))
# define __kernel	__attribute__((address_space(0)))
# define __safe		__attribute__((safe))
# define __force	__attribute__((force))
# define __nocast	__attribute__((nocast))
# define __iomem	__attribute__((noderef, address_space(2)))
# define __acquires(x)	__attribute__((context(x,0,1)))
# define __releases(x)	__attribute__((context(x,1,0)))
# define __acquire(x)	__context__(x,1)
# define __release(x)	__context__(x,-1)
# define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
# define __percpu	__attribute__((noderef, address_space(3)))
# define __rcu		__attribute__((noderef, address_space(4)))
#else
# define __user
# define __kernel
# define __safe
# define __force
# define __nocast
# define __iomem
# define __acquires(x)
# define __releases(x)
# define __acquire(x) (void)0
# define __release(x) (void)0
# define __cond_lock(x,c) (c)
# define __percpu
# define __rcu
#endif

#define ___PASTE(a,b) a##b
#define __PASTE(a,b) ___PASTE(a,b)

#define __deprecated		__attribute__((deprecated))
#define __packed		__attribute__((packed))
#define __weak			__attribute__((weak))
#define __always_inline		inline __attribute__((always_inline))
#define __pure			__attribute__((pure))
#define __aligned(x)		__attribute__((aligned(x)))
#define __printf(a, b)		__attribute__((format(printf, a, b)))
#define __scanf(a, b)		__attribute__((format(scanf, a, b)))
#define __attribute_const__	__attribute__((__const__))
#define __maybe_unused		__attribute__((unused))
#define __always_unused		__attribute__((unused))
#define __used			__attribute__((__used__))
#define __must_check		__attribute__((warn_unused_result))
#define __cold			__attribute__((__cold__))
#define __section(S)		__attribute__ ((__section__(#S)))
#define __visible		__attribute__((externally_visible))

#define likely(x)		__builtin_expect(!!(x), 1)
#define unlikely(x)		__builtin_expect(!!(x), 0)

#define barrier()		__asm__ __volatile__("": : :"memory")

#ifndef noinline
#define noinline		__attribute__((noinline))
#endif

#define noinline_for_stack	noinline
#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
#define unreachable() do { __builtin_unreachable(); } while (0)

#define RELOC_HIDE(ptr, off)	\
  ({ unsigned long __ptr;	\
     __ptr = (unsigned long) (ptr);	\
    (typeof(ptr)) (__ptr + (off)); })

#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)

#define __compiletime_warning(message)
#define __compiletime_error(message)
#define __compiletime_error_fallback(condition) do { } while (0)
#define __compiletime_object_size(obj) -1
#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))
#define __native_word(t) (sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))

#define __kprobes
#define read_barrier_depends() do { } while (0)

#endif /* __ASSEMBLY__ */
#endif /* __LINUX_COMPILER_H */
EOF
    fi

    # CORREÇÃO 2: Criar asm-offsets.c simplificado
    cat > arch/arm/kernel/asm-offsets.c << 'EOF'
/*
 * linux/arch/arm/kernel/asm-offsets.c
 * PostmarketOS minimal version
 */

#define DEFINE(sym, val) \
        __asm__ __volatile__("\n->" #sym " %0 " #val : : "i" (val))

#define BLANK() \
        __asm__ __volatile__("\n->" : : )

int main(void)
{
  DEFINE(TI_FLAGS, 0);
  DEFINE(TI_PREEMPT, 4);
  DEFINE(TI_ADDR_LIMIT, 8);
  DEFINE(TI_TASK, 12);
  DEFINE(TI_CPU, 16);
  DEFINE(TI_CPU_DOMAIN, 20);
  DEFINE(TI_CPU_SAVE, 24);
  DEFINE(TI_USED_CP, 76);
  DEFINE(TI_TP_VALUE, 96);
  DEFINE(TI_FPSTATE, 144);
  BLANK();
  DEFINE(S_R0, 0);
  DEFINE(S_R1, 4);
  DEFINE(S_R2, 8);
  DEFINE(S_R3, 12);
  DEFINE(S_R4, 16);
  DEFINE(S_R5, 20);
  DEFINE(S_R6, 24);
  DEFINE(S_R7, 28);
  DEFINE(S_R8, 32);
  DEFINE(S_R9, 36);
  DEFINE(S_R10, 40);
  DEFINE(S_FP, 44);
  DEFINE(S_IP, 48);
  DEFINE(S_SP, 52);
  DEFINE(S_LR, 56);
  DEFINE(S_PC, 60);
  DEFINE(S_PSR, 64);
  DEFINE(S_OLD_R0, 68);
  DEFINE(S_FRAME_SIZE, 72);
  BLANK();
  DEFINE(PAGE_SZ, 4096);
  BLANK();
  return 0;
}
EOF

    # CORREÇÃO 3: Criar page-flags.h
    mkdir -p include/linux
    cat > include/linux/page-flags.h << 'EOF'
#ifndef PAGE_FLAGS_H
#define PAGE_FLAGS_H

#include <linux/types.h>

enum pageflags {
    PG_locked,
    PG_error,
    PG_referenced,
    PG_uptodate,
    PG_dirty,
    PG_lru,
    PG_active,
    PG_slab,
    PG_owner_priv_1,
    PG_arch_1,
    PG_reserved,
    PG_private,
    PG_private_2,
    PG_writeback,
    PG_head,
    PG_tail,
    PG_swapcache,
    PG_mappedtodisk,
    PG_reclaim,
    PG_swapbacked,
    PG_unevictable,
    PG_mlocked,
    PG_readahead,
    __NR_PAGEFLAGS,
};

#ifndef __GENERATING_BOUNDS_H

static inline int PageLocked(struct page *page) { return 0; }
static inline int PageError(struct page *page) { return 0; }
static inline int PageReferenced(struct page *page) { return 0; }
static inline int PageUptodate(struct page *page) { return 1; }
static inline int PageDirty(struct page *page) { return 0; }
static inline int PageLRU(struct page *page) { return 0; }
static inline int PageActive(struct page *page) { return 0; }
static inline int PageSlab(struct page *page) { return 0; }
static inline int PageReserved(struct page *page) { return 0; }
static inline int PagePrivate(struct page *page) { return 0; }
static inline int PageWriteback(struct page *page) { return 0; }
static inline int PageReadahead(struct page *page) { return 0; }

static inline void SetPageLocked(struct page *page) { }
static inline void SetPageError(struct page *page) { }
static inline void SetPageReferenced(struct page *page) { }
static inline void SetPageUptodate(struct page *page) { }
static inline void SetPageDirty(struct page *page) { }
static inline void SetPageLRU(struct page *page) { }
static inline void SetPageActive(struct page *page) { }
static inline void SetPageSlab(struct page *page) { }
static inline void SetPageReserved(struct page *page) { }
static inline void SetPagePrivate(struct page *page) { }
static inline void SetPageWriteback(struct page *page) { }

static inline void ClearPageLocked(struct page *page) { }
static inline void ClearPageError(struct page *page) { }
static inline void ClearPageReferenced(struct page *page) { }
static inline void ClearPageUptodate(struct page *page) { }
static inline void ClearPageDirty(struct page *page) { }
static inline void ClearPageLRU(struct page *page) { }
static inline void ClearPageActive(struct page *page) { }
static inline void ClearPageSlab(struct page *page) { }
static inline void ClearPageReserved(struct page *page) { }
static inline void ClearPagePrivate(struct page *page) { }
static inline void ClearPageWriteback(struct page *page) { }

#endif /* !__GENERATING_BOUNDS_H */
#endif /* PAGE_FLAGS_H */
EOF

    # CORREÇÃO 4: Corrigir VFP entry.S com offsets hardcoded
    if [ -f arch/arm/vfp/entry.S ]; then
        _log "Corrigindo VFP entry.S..."
        sed -i 's/#TI_PREEMPT/#8/g' arch/arm/vfp/entry.S 2>/dev/null || true
        sed -i 's/#S_PC/#60/g' arch/arm/vfp/entry.S 2>/dev/null || true
        sed -i 's/#TI_CPU/#20/g' arch/arm/vfp/entry.S 2>/dev/null || true
        sed -i 's/#TI_VFPSTATE/#144/g' arch/arm/vfp/entry.S 2>/dev/null || true
    fi

    # CORREÇÃO 5: Criar kbuild.h se não existir
    if [ ! -f include/linux/kbuild.h ]; then
        _log "Criando include/linux/kbuild.h..."
        mkdir -p include/linux
        cat > include/linux/kbuild.h << 'EOF'
#ifndef __LINUX_KBUILD_H
#define __LINUX_KBUILD_H

#define DEFINE(sym, val) \
        __asm__ __volatile__("\n->" #sym " %0 " #val : : "i" (val))

#define BLANK() \
        __asm__ __volatile__("\n->" : : )

#define OFFSET(sym, str, mem) \
        DEFINE(sym, offsetof(struct str, mem))

#define COMMENT(x) \
        __asm__ __volatile__("\n->#" x)

#endif
EOF
    fi

    # CORREÇÃO 6: const.h para _AC macro
    if [ -f include/linux/const.h ]; then
        if ! grep -q "__AC" include/linux/const.h; then
            _log "Adicionando macro _AC ao const.h..."
            cat >> include/linux/const.h << 'EOF'

#ifndef __AC
#define __AC(X,Y)	(X##Y)
#define _AC(X,Y)	__AC(X,Y)
#endif
EOF
        fi
    fi

    # CORREÇÃO 7: Memory macros
    if [ -f arch/arm/include/asm/memory.h ]; then
        if ! grep -q "GCC 15+ compatibility" arch/arm/include/asm/memory.h; then
            _log "Corrigindo memory.h..."
            sed -i '/^#ifndef _ASMARM_MEMORY_H/a\
\
/* GCC 15+ compatibility - UL macro fix */\
#ifndef __ASSEMBLY__\
#ifndef UL\
#define UL(x) _AC(x, UL)\
#endif\
#else\
#define UL(x) (x)\
#endif' arch/arm/include/asm/memory.h

            sed -i 's/#define PAGE_OFFSET.*UL(CONFIG_PAGE_OFFSET).*/#define PAGE_OFFSET             UL(0xC0000000)/' arch/arm/include/asm/memory.h
            sed -i 's/#define PHYS_OFFSET.*UL(CONFIG_PHYS_OFFSET).*/#define PHYS_OFFSET             UL(0x00000000)/' arch/arm/include/asm/memory.h
        fi
    fi

    # CORREÇÃO 8: Makefile flags mais conservadores
    if [ -f Makefile ]; then
        if ! grep -q "CONSERVATIVE_GCC_FLAGS" Makefile; then
            _log "Adicionando flags conservadores ao Makefile..."
            cat >> Makefile << 'EOF'

# CONSERVATIVE_GCC_FLAGS - More conservative approach
KBUILD_CFLAGS += -fgnu89-inline -std=gnu89
KBUILD_CFLAGS += -Wno-error=format -Wno-error=format-overflow -Wno-error=format-truncation
KBUILD_CFLAGS += -Wno-error=stringop-overflow -Wno-error=stringop-truncation
KBUILD_CFLAGS += -Wno-error=array-bounds -Wno-error=dangling-pointer
KBUILD_CFLAGS += -Wno-error=address -Wno-error=maybe-uninitialized
KBUILD_CFLAGS += -Wno-macro-redefined
HOSTCFLAGS := -fgnu89-inline -std=gnu89 -O2 -static
HOSTCXXFLAGS := -fgnu89-inline -O2 -static
HOSTLDFLAGS := -static
EOF
        fi
    fi

    # CORREÇÃO 9: Corrigir redefinição do __LINUX_ARM_ARCH__
    if [ -f arch/arm/Makefile ]; then
        sed -i 's/KBUILD_CFLAGS.*+= -D__LINUX_ARM_ARCH__=$(arch-y)/ifeq ($(filter -D__LINUX_ARM_ARCH__%,$(KBUILD_CFLAGS)),)\nKBUILD_CFLAGS += -D__LINUX_ARM_ARCH__=$(arch-y)\nendif/' arch/arm/Makefile 2>/dev/null || true
    fi

    # CORREÇÃO 10: Criar sizes.h faltante
    mkdir -p include/linux
    cat > include/linux/sizes.h << 'EOF'
#ifndef __LINUX_SIZES_H__
#define __LINUX_SIZES_H__

#define SZ_1				0x00000001
#define SZ_2				0x00000002
#define SZ_4				0x00000004
#define SZ_8				0x00000008
#define SZ_16				0x00000010
#define SZ_32				0x00000020
#define SZ_64				0x00000040
#define SZ_128				0x00000080
#define SZ_256				0x00000100
#define SZ_512				0x00000200

#define SZ_1K				0x00000400
#define SZ_2K				0x00000800
#define SZ_4K				0x00001000
#define SZ_8K				0x00002000
#define SZ_16K				0x00004000
#define SZ_32K				0x00008000
#define SZ_64K				0x00010000
#define SZ_128K				0x00020000
#define SZ_256K				0x00040000
#define SZ_512K				0x00080000

#define SZ_1M				0x00100000
#define SZ_2M				0x00200000
#define SZ_4M				0x00400000
#define SZ_8M				0x00800000
#define SZ_16M				0x01000000
#define SZ_32M				0x02000000
#define SZ_64M				0x04000000
#define SZ_128M				0x08000000
#define SZ_256M				0x10000000
#define SZ_512M				0x20000000

#define SZ_1G				0x40000000
#define SZ_2G				0x80000000

#endif /* __LINUX_SIZES_H__ */
EOF

    _log "Todas as correções aplicadas"
}

prepare() {
    cd "$builddir"
    _log "Preparando kernel Matisse3G..."

    # 1. Configurar ambiente (ordem importante!)
    _detect_cross_compiler
    _setup_gcc15_environment

    # 2. NOVO: Corrigir headers fundamentais PRIMEIRO
    _fix_fundamental_headers

    # 3. Aplicar correções via código DEPOIS dos headers
    _apply_code_fixes

    # 4. Aplicar patches disponíveis DEPOIS das correções
    _log "Aplicando patches disponíveis..."
    for patch in $source; do
        case $patch in
            *.patch)
                if [ -f "$srcdir/$patch" ]; then
                    _log "Aplicando $patch..."
                    patch -p1 -i "$srcdir/$patch" || _log "AVISO: $patch falhou"
                fi
                ;;
        esac
    done

    # 5. Configuração com CROSS_COMPILE definido
    if [ -f "$srcdir/config-samsung-matisse3g.armv7" ]; then
        _log "Aplicando configuração do dispositivo..."
        cp "$srcdir/config-samsung-matisse3g.armv7" .config
        echo "CONFIG_CROSS_COMPILE=\"$CROSS_COMPILE\"" >> .config
    fi

    # 6. Criar arquivos necessários
    mkdir -p include/generated include/config scripts/basic scripts/kconfig
    echo '#define UTS_RELEASE "3.4.113"' > include/generated/utsrelease.h
    echo '/* Auto generated */' > include/generated/autoconf.h
    touch include/generated/bounds.h
    touch include/generated/asm-offsets.h

    # 7. Preparar build com configuração não-interativa
    make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" \
         HOSTCC="$HOSTCC" HOSTCFLAGS="$HOSTCFLAGS" HOSTLDFLAGS="$HOSTLDFLAGS" \
         EXTRA_CFLAGS="$EXTRA_CFLAGS" \
         scripts_basic 2>/dev/null || _log "AVISO: scripts_basic falhou"

    yes "" | make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" \
         HOSTCC="$HOSTCC" HOSTCFLAGS="$HOSTCFLAGS" HOSTLDFLAGS="$HOSTLDFLAGS" \
         EXTRA_CFLAGS="$EXTRA_CFLAGS" \
         oldconfig 2>/dev/null || _log "AVISO: oldconfig falhou"

    _log "Preparação concluída"
}

build() {
    cd "$builddir"
    _log "Compilando kernel com supressão agressiva de warnings..."

    if [ -f include/generated/utsrelease.h ]; then
        chmod 444 include/generated/utsrelease.h
    fi

    make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" \
         HOSTCC="$HOSTCC" HOSTCFLAGS="$HOSTCFLAGS" HOSTLDFLAGS="$HOSTLDFLAGS" \
         KCFLAGS="$KCFLAGS" AFLAGS="$AFLAGS" \
         EXTRA_CFLAGS="$EXTRA_CFLAGS -w" \
         KERNELRELEASE="$KERNELRELEASE" UTS_RELEASE="$UTS_RELEASE" \
         -j$(nproc) zImage 2>&1 | grep -E "(error:|Error:|ERROR:|fatal)" || true

    if [ ! -f arch/arm/boot/zImage ]; then
        _die "zImage não foi criado"
    fi

    make ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" \
         HOSTCC="$HOSTCC" HOSTCFLAGS="$HOSTCFLAGS" HOSTLDFLAGS="$HOSTLDFLAGS" \
         KCFLAGS="$KCFLAGS" AFLAGS="$AFLAGS" \
         EXTRA_CFLAGS="$EXTRA_CFLAGS -w" \
         KERNELRELEASE="$KERNELRELEASE" UTS_RELEASE="$UTS_RELEASE" \
         -j$(nproc) modules 2>&1 | grep -E "(error:|Error:|ERROR:|fatal)" || _log "Módulos compilados (com avisos)"

    _log "Compilação concluída com sucesso!"
}

package() {
    cd "$builddir"
    _log "Empacotando kernel..."

    install -Dm644 arch/arm/boot/zImage "$pkgdir/boot/vmlinuz-$_flavor"

    make DESTDIR="$pkgdir" INSTALL_MOD_PATH="$pkgdir" \
         ARCH=arm CROSS_COMPILE="$CROSS_COMPILE" \
         modules_install 2>/dev/null || _log "AVISO: Módulos falharam"

    if [ -d arch/arm/boot/dts ]; then
        dtb_count=$(find arch/arm/boot/dts -name "*.dtb" 2>/dev/null | wc -l)
        if [ "$dtb_count" -gt 0 ]; then
            mkdir -p "$pkgdir/boot/dtbs-$_flavor"
            find arch/arm/boot/dts -name "*.dtb" -exec cp {} "$pkgdir/boot/dtbs-$_flavor/" \; 2>/dev/null
        fi
    fi

    mkdir -p "$pkgdir/boot"
    ln -sf "vmlinuz-$_flavor" "$pkgdir/boot/vmlinuz" || true

    _log "Empacotamento concluído"
}

sha512sums="
7fa4253037e154e2f245e12b4d7999887d6fcf99c9e7d30601ecf53a2fe5d47f1a423dd9483dac9eec86b7e5a9daf0b48e8ddde7311cd091a66630ff0656bd45  linux-samsung-matisse3g-pmos-matisse3g-fixes.tar.gz
4eff4dab705a03c3ce5082b00469b1d8728f6cda27a5e79786cc9bdb299f8421d016c74b0aa3e3da39e6849ac39d962b5a11aa7794ba18c5a376161447147c31  config-samsung-matisse3g.armv7
f3bbc54d1c3433310f701c0da130c165d8baab29d924ad90a7021c40818e767066c10b6c2467b97d92b43191a7d0e1bb389dc056463263c14347e9e4582ae0ca  01-fix-timex-header.patch
726321e16d16edad715abd4bc83e9f546902e11b5d2c5f5ab1b7076872ad0fceee85d2e512e8007a78c0a956b3454b239b9a844149a87094a342d91030972889  03-fix-defconfig.patch
7462871c23903b5b061117757adb82da2e80caeadf44f941686ca1bba8c67a337d5d1ffdf94350cdd964ecc7651adec6770cc0801e18e60872b72490e917fa02  04-fix-jffs2-format-warnings.patch
"
