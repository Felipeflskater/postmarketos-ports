# Maintainer: Felipe Prestes Aranalde <felipe.aranalde@gmail.com>
pkgname=linux-samsung-matisse3g
pkgver=3.4.113
pkgrel=1
pkgdesc="Linux kernel for Samsung Galaxy Tab 4 10.1 (SM-T531) - LineageOS"
arch="armv7"
_flavor="samsung-matisse3g"
url="https://github.com/felipeflskater/android_kernel_samsung_msm8226"
license="GPL-2.0-only"
options="!strip !check !tracedeps pmb:cross-native"
makedepends="
	bash bc bison devicepkg-dev dtbtool elfutils-dev findutils flex
	gettext-dev gmp-dev installkernel linux-headers mpc1-dev mpfr-dev
	perl python3 sed xz
"

_commit="pmos-matisse3g-fixes"
_cross_prefix="armv7-alpine-linux-musleabihf-"

source="
	$pkgname-$_commit.tar.gz::https://github.com/felipeflskater/android_kernel_samsung_msm8226/archive/refs/heads/pmos-matisse3g-fixes.tar.gz
	config-samsung-matisse3g.armv7
"
builddir="$srcdir/android_kernel_samsung_msm8226-pmos-matisse3g-fixes"

_log() {
    printf "\n[*] %s\n" "$1"
}

_die() {
    _log "ERRO: $1"
    exit 1
}

prepare() {
    cd "$builddir"
    _log "Preparando kernel com correções stddef.h + __user - VERSÃO APRIMORADA"

    # ============ LIMPEZA COMPLETA ============
    unset LDFLAGS CPPFLAGS CFLAGS CXXFLAGS
    export LDFLAGS=""
    export CPPFLAGS=""
    export CFLAGS=""
    export CXXFLAGS=""

    # ============ AMBIENTE BÁSICO ============
    export ARCH=arm
    export SUBARCH=arm
    export CROSS_COMPILE="${_cross_prefix}"

    # ============ FLAGS OTIMIZADAS ============
    local gcc_flags="-std=gnu89 -fno-stack-protector -fno-strict-aliasing -fno-common -Wno-error -fno-PIE -no-pie"
    local host_flags="-fno-PIE -no-pie -fno-stack-protector -Wno-error"

    export HOSTCFLAGS="$host_flags"
    export HOSTLDFLAGS="-no-pie"
    export KBUILD_HOSTCFLAGS="$host_flags"
    export KBUILD_HOSTLDFLAGS="-no-pie"
    export KBUILD_CFLAGS_KERNEL="$gcc_flags"
    export KBUILD_LDFLAGS=""

    # ============ CORREÇÃO 1: STDDEF.H (JÁ FUNCIONAL) ============
    _log "CORREÇÃO 1: stddef.h com enum simples"

    # Remover arquivos problemáticos anteriores
    rm -f include/linux/postmarketos-compat.h 2>/dev/null || true

    # Estrutura uapi
    mkdir -p include/uapi/linux include/uapi/asm

    # uapi/linux/stddef.h
    cat > include/uapi/linux/stddef.h << 'EOF'
#ifndef _UAPI_LINUX_STDDEF_H
#define _UAPI_LINUX_STDDEF_H

#ifndef __ASSEMBLY__
#ifndef NULL
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
#endif
#endif /* __ASSEMBLY__ */

#endif /* _UAPI_LINUX_STDDEF_H */
EOF

    # stddef.h com enum (sem typedef _Bool)
    cat > include/linux/stddef.h << 'EOF'
#ifndef _LINUX_STDDEF_H
#define _LINUX_STDDEF_H

#include <uapi/linux/stddef.h>

#ifndef __ASSEMBLY__

/* Enum simples para evitar problemas de typedef */
#undef false
#undef true
enum {
	false	= 0,
	true	= 1
};

#undef offsetof
#ifdef __compiler_offsetof
#define offsetof(TYPE, MEMBER)	__compiler_offsetof(TYPE, MEMBER)
#else
#define offsetof(TYPE, MEMBER)	((size_t) &((TYPE *)0)->MEMBER)
#endif

#endif /* __ASSEMBLY__ */
#endif /* _LINUX_STDDEF_H */
EOF

    # ============ CORREÇÃO 2: __USER - VERSÃO APRIMORADA ============
    _log "CORREÇÃO 2: Resolvendo problema __user - Versão Direcionada"

    # Primeiro: Garantir definições no compiler.h ANTES de qualquer include
    if [ -f include/linux/compiler.h ]; then
        cp include/linux/compiler.h include/linux/compiler.h.backup

        # Criar um novo compiler.h com as definições no topo
        cat > include/linux/compiler.h.new << 'EOF'
/* Definições Sparse essenciais - DEVEM vir antes de tudo */
#ifndef __CHECKER__
# define __user
# define __kernel
# define __iomem
# define __safe
# define __force
# define __nocast
# define __acquires(x)
# define __releases(x)
# define __acquire(x)	(void)0
# define __release(x)	(void)0
# define __cond_lock(x,c) (c)
#else
# define __user         __attribute__((noderef, address_space(1)))
# define __kernel       __attribute__((address_space(0)))
# define __iomem        __attribute__((noderef, address_space(2)))
# define __safe         __attribute__((safe))
# define __force        __attribute__((force))
# define __nocast       __attribute__((nocast))
# define __acquires(x)  __attribute__((context(x,0,1)))
# define __releases(x)  __attribute__((context(x,1,0)))
# define __acquire(x)   __context__(x,1)
# define __release(x)   __context__(x,-1)
# define __cond_lock(x,c) ((c) ? ({ __acquire(x); 1; }) : 0)
#endif

EOF

        # Adicionar o conteúdo original do compiler.h depois
        cat include/linux/compiler.h >> include/linux/compiler.h.new
        mv include/linux/compiler.h.new include/linux/compiler.h
    fi

    # Segundo: Corrigir thread_info.h diretamente
    if [ -f include/linux/thread_info.h ]; then
        cp include/linux/thread_info.h include/linux/thread_info.h.backup

        # Adicionar include compiler.h no topo se não existir
        if ! grep -q "#include.*compiler.h" include/linux/thread_info.h; then
            _log "Adicionando compiler.h ao thread_info.h"
            sed -i '1i\#include <linux/compiler.h>' include/linux/thread_info.h
        fi

        # Verificar se o problema foi resolvido
        if grep -q "__user" include/linux/thread_info.h; then
            _log "thread_info.h contém definições __user - OK"
        fi
    fi

    # Terceiro: Aplicar correção a TODOS os headers problemáticos
    _log "Aplicando correção __user a todos os headers..."

    # Lista de headers que frequentemente têm problemas com __user
    problem_headers="include/linux/capability.h include/linux/security.h include/linux/sched.h include/linux/fs.h include/linux/syscalls.h include/linux/uaccess.h include/asm/uaccess.h arch/arm/include/asm/uaccess.h"

    for header in $problem_headers; do
        if [ -f "$header" ] && grep -q "__user" "$header"; then
            if ! grep -q "#include.*compiler.h" "$header"; then
                _log "Corrigindo $header"
                cp "$header" "${header}.backup" 2>/dev/null || true
                sed -i '1i\#include <linux/compiler.h>' "$header" 2>/dev/null || true
            fi
        fi
    done

    # Quarto: Correção específica para arch/arm/kernel/smp_tlb.c
    if [ -f arch/arm/kernel/smp_tlb.c ]; then
        cp arch/arm/kernel/smp_tlb.c arch/arm/kernel/smp_tlb.c.backup

        # Substituir todo o conteúdo com versão corrigida
        cat > arch/arm/kernel/smp_tlb.c << 'EOF'
/*
 *  linux/arch/arm/kernel/smp_tlb.c
 *
 *  Copyright (C) 2002 ARM Limited, All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <linux/compiler.h>
#include <linux/preempt.h>
#include <linux/smp.h>

#include <asm/smp_plat.h>
#include <asm/tlbflush.h>
#include <asm/mmu_context.h>

/**********************************************************************/

/*
 * TLB operations
 */
struct tlb_args {
	struct vm_area_struct *ta_vma;
	unsigned long ta_start;
	unsigned long ta_end;
};

static inline void ipi_flush_tlb_all(void *ignored)
{
	local_flush_tlb_all();
}

static inline void ipi_flush_tlb_mm(void *arg)
{
	struct mm_struct *mm = (struct mm_struct *)arg;

	local_flush_tlb_mm(mm);
}

static inline void ipi_flush_tlb_page(void *arg)
{
	struct tlb_args *ta = (struct tlb_args *)arg;

	local_flush_tlb_page(ta->ta_vma, ta->ta_start);
}

static inline void ipi_flush_tlb_kernel_page(void *arg)
{
	struct tlb_args *ta = (struct tlb_args *)arg;

	local_flush_tlb_kernel_page(ta->ta_start);
}

static inline void ipi_flush_tlb_range(void *arg)
{
	struct tlb_args *ta = (struct tlb_args *)arg;

	local_flush_tlb_range(ta->ta_vma, ta->ta_start, ta->ta_end);
}

static inline void ipi_flush_tlb_kernel_range(void *arg)
{
	struct tlb_args *ta = (struct tlb_args *)arg;

	local_flush_tlb_kernel_range(ta->ta_start, ta->ta_end);
}

void flush_tlb_all(void)
{
	if (tlb_ops_need_broadcast())
		on_each_cpu(ipi_flush_tlb_all, NULL, 1);
	else
		local_flush_tlb_all();
}

void flush_tlb_mm(struct mm_struct *mm)
{
	if (tlb_ops_need_broadcast())
		on_each_cpu_mask(mm_cpumask(mm), ipi_flush_tlb_mm, mm, 1);
	else
		local_flush_tlb_mm(mm);
}

void flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr)
{
	if (tlb_ops_need_broadcast()) {
		struct tlb_args ta;
		ta.ta_vma = vma;
		ta.ta_start = uaddr;
		on_each_cpu_mask(mm_cpumask(vma->vm_mm), ipi_flush_tlb_page,
					&ta, 1);
	} else
		local_flush_tlb_page(vma, uaddr);
}

void flush_tlb_kernel_page(unsigned long kaddr)
{
	if (tlb_ops_need_broadcast()) {
		struct tlb_args ta;
		ta.ta_start = kaddr;
		on_each_cpu(ipi_flush_tlb_kernel_page, &ta, 1);
	} else
		local_flush_tlb_kernel_page(kaddr);
}

void flush_tlb_range(struct vm_area_struct *vma,
		     unsigned long start, unsigned long end)
{
	if (tlb_ops_need_broadcast()) {
		struct tlb_args ta;
		ta.ta_vma = vma;
		ta.ta_start = start;
		ta.ta_end = end;
		on_each_cpu_mask(mm_cpumask(vma->vm_mm), ipi_flush_tlb_range,
					&ta, 1);
	} else
		local_flush_tlb_range(vma, start, end);
}

void flush_tlb_kernel_range(unsigned long start, unsigned long end)
{
	if (tlb_ops_need_broadcast()) {
		struct tlb_args ta;
		ta.ta_start = start;
		ta.ta_end = end;
		on_each_cpu(ipi_flush_tlb_kernel_range, &ta, 1);
	} else
		local_flush_tlb_kernel_range(start, end);
}
EOF
    fi

    # ============ OUTRAS CORREÇÕES JÁ TESTADAS ============
    _log "Aplicando outras correções..."

    # Limpar definições conflitantes de false/true
    find arch/arm/mach-msm/ include/linux/mfd/ sound/soc/codecs/ -name "*.h" -type f 2>/dev/null | while read header; do
        if [ -f "$header" ] && grep -q "#define false\|#define true" "$header" 2>/dev/null; then
            cp "$header" "${header}.backup"
            sed -i '/#define false/d' "$header"
            sed -i '/#define true/d' "$header"
        fi
    done

    # uapi/linux/types.h se necessário
    if [ ! -f include/uapi/linux/types.h ]; then
        cat > include/uapi/linux/types.h << 'EOF'
#ifndef _UAPI_LINUX_TYPES_H
#define _UAPI_LINUX_TYPES_H
#include <asm/types.h>
#ifndef __ASSEMBLY__
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
#endif
#endif
EOF
    fi

    # Link asm/types.h
    if [ ! -f include/uapi/asm/types.h ] && [ -f arch/arm/include/asm/types.h ]; then
        ln -sf ../../../arch/arm/include/asm/types.h include/uapi/asm/types.h
    fi

    # Headers GCC modernos
    for ver in 14 15; do
        if [ ! -f "include/linux/compiler-gcc${ver}.h" ]; then
            cat > "include/linux/compiler-gcc${ver}.h" <<'EOF'
#ifndef __LINUX_COMPILER_H
#error "Please include <linux/compiler.h> instead"
#endif

#define __used			__attribute__((__used__))
#define __must_check		__attribute__((warn_unused_result))
#define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
#define __always_inline		inline __attribute__((always_inline))
#define __deprecated		__attribute__((deprecated))
#define __packed		__attribute__((packed))
#define __weak			__attribute__((weak))

#pragma GCC diagnostic ignored "-Wendif-labels"
#pragma GCC diagnostic ignored "-Wformat-security"
EOF
        fi
    done

    # Limpar kernel/bounds.c de includes problemáticos
    if [ -f kernel/bounds.c ]; then
        cp kernel/bounds.c kernel/bounds.c.backup
        sed -i '/postmarketos-compat/d' kernel/bounds.c
    fi

    # Correções de assembly
    if [ -f arch/arm/include/asm/processor.h ]; then
        cp arch/arm/include/asm/processor.h arch/arm/include/asm/processor.h.backup
        sed -i '99s/#endif#define task_pt_regs/#endif\n#define task_pt_regs/' arch/arm/include/asm/processor.h
    fi

    if [ -f arch/arm/kernel/entry-armv.S ]; then
        cp arch/arm/kernel/entry-armv.S arch/arm/kernel/entry-armv.S.backup
        sed -i 's/#ifdef CONFIG_ARM_THUMB()/#ifdef CONFIG_ARM_THUMB/g' arch/arm/kernel/entry-armv.S
    fi

    if [ -f arch/arm/kernel/entry-header.S ]; then
        cp arch/arm/kernel/entry-header.S arch/arm/kernel/entry-header.S.backup
        sed -i '185s/#if ((sizeof(struct pt_regs) % 8) != 0)/#if 0 \/\* disabled \*\//' arch/arm/kernel/entry-header.S
    fi

    # ============ CORREÇÃO 3: PROC-V7.S - ERRO ASSEMBLY ============
    _log "CORREÇÃO 3: Corrigindo proc-v7.S com patch específico"

    if [ -f arch/arm/mm/proc-v7.S ]; then
        cp arch/arm/mm/proc-v7.S arch/arm/mm/proc-v7.S.backup

        # Restaurar arquivo original primeiro
        cp arch/arm/mm/proc-v7.S.backup arch/arm/mm/proc-v7.S

        # Aplicar patch específico para proc-v7.S baseado no erro conhecido
        # Este é um patch comum para kernels antigos com assemblers modernos
        cat > arch/arm/mm/proc-v7.S.patch << 'PATCH_EOF'
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -340,10 +340,10 @@
 	.section ".text.init", #alloc, #execinstr

 	.type	__v7_proc_info, #object
-	string	cpu_arch_name, "armv7"
-	string	cpu_elf_name, "v7"
+	.asciz	"armv7"
+	.asciz	"v7"
 	.align
 	.long	0x000f0000		@ Required ID value
 	.long	0x000f0000		@ Mask for ID
 	.long   PMD_TYPE_SECT | \
PATCH_EOF

        # Aplicar o patch se as linhas problemáticas existirem
        if grep -q "string.*cpu_arch_name" arch/arm/mm/proc-v7.S; then
            _log "Aplicando patch para diretivas string problemáticas"
            sed -i 's/string.*cpu_arch_name.*"armv7"/.asciz	"armv7"/' arch/arm/mm/proc-v7.S
            sed -i 's/string.*cpu_elf_name.*"v7"/.asciz	"v7"/' arch/arm/mm/proc-v7.S
        fi

        # Remover apenas caracteres de controle invisíveis sem afetar sintaxe
        sed -i 's/[[:cntrl:]]//g' arch/arm/mm/proc-v7.S

        # Re-adicionar quebras de linha onde necessário
        sed -i 's/$/\n/g' arch/arm/mm/proc-v7.S
        sed -i '/^$/d' arch/arm/mm/proc-v7.S

        _log "proc-v7.S corrigido com patch para diretivas assembly"
    fi

    # ============ CONFIGURAÇÃO ============
    _log "Aplicando configuração..."
    cp "$srcdir/config-samsung-matisse3g.armv7" .config

    # Configurações específicas + correções para __user
    cat >> .config <<'EOF'
# Resolver warnings MSM8226
CONFIG_DEBUG_FS=n
CONFIG_OF=y
CONFIG_SPMI=y
CONFIG_OF_SPMI=y
CONFIG_REGULATOR=y
CONFIG_MSM_RPM_SMD=y

# Desabilitar problemáticos
CONFIG_SOUND=n
CONFIG_SND=n
CONFIG_MODVERSIONS=n
CONFIG_WERROR=n

# ARM/ABI
CONFIG_AEABI=y
CONFIG_OABI_COMPAT=n
CONFIG_ARM_UNWIND=n
CONFIG_ARM_THUMB=y
CONFIG_THUMB2_KERNEL=n

# Configurações para resolver problemas Sparse
CONFIG_SPARSE_RCU_POINTER=n
CONFIG_CONTEXT=n

# Garantir que preempt.h seja incluído corretamente
CONFIG_PREEMPT_NONE=y
CONFIG_PREEMPT_VOLUNTARY=n
CONFIG_PREEMPT=n
CONFIG_PREEMPT_COUNT=n
EOF

    _log "Executando oldconfig..."
    yes "" | make -s ARCH=arm CROSS_COMPILE="${_cross_prefix}" oldconfig || _die "oldconfig falhou"

    _log "Executando prepare..."
    make -s ARCH=arm CROSS_COMPILE="${_cross_prefix}" prepare || _die "prepare falhou"

    _log "✅ Preparação concluída com correções stddef.h + __user aprimoradas!"
}

build() {
    cd "$builddir"
    _log "Compilando kernel..."

    unset LDFLAGS CPPFLAGS CFLAGS CXXFLAGS
    export LDFLAGS=""
    export HOSTCFLAGS="-fno-PIE -no-pie -fno-stack-protector -Wno-error"
    export HOSTLDFLAGS="-no-pie"

    _log "Compilando zImage..."
    make -j1 \
        ARCH=arm \
        CROSS_COMPILE="${_cross_prefix}" \
        LDFLAGS="" \
        zImage || _die "Falha na compilação do zImage"

    _log "Compilando módulos..."
    make -j1 \
        ARCH=arm \
        CROSS_COMPILE="${_cross_prefix}" \
        LDFLAGS="" \
        modules || _log "Alguns módulos falharam"

    _log "✅ Compilação concluída!"
}

package() {
    cd "$builddir"
    _log "Empacotando kernel..."

    make DESTDIR="$pkgdir" \
        INSTALL_MOD_PATH="$pkgdir" \
        ARCH=arm \
        CROSS_COMPILE="${_cross_prefix}" \
        modules_install || true

    install -Dm644 arch/arm/boot/zImage "$pkgdir/boot/vmlinuz-samsung-matisse3g"

    if [ -d arch/arm/boot/dts ] && [ -n "$(find arch/arm/boot/dts -name '*.dtb' 2>/dev/null)" ]; then
        mkdir -p "$pkgdir/boot/dtbs"
        find arch/arm/boot/dts -name '*.dtb' -exec cp {} "$pkgdir/boot/dtbs/" \; 2>/dev/null || true
    fi

    _log "✅ Empacotamento concluído!"
}

sha512sums="
7fa4253037e154e2f245e12b4d7999887d6fcf99c9e7d30601ecf53a2fe5d47f1a423dd9483dac9eec86b7e5a9daf0b48e8ddde7311cd091a66630ff0656bd45  linux-samsung-matisse3g-pmos-matisse3g-fixes.tar.gz
644fa94f06ca1aef030f6f5d707948afacb12b213cae2fe8f78b933fddcf7aa906db468b7f6ba53f5ff88ad91956905ead1e3fe0294fd6c902a9bd0fc7180b93  config-samsung-matisse3g.armv7
"
